When reading the following material, I suggest you have Eclipse open, including
a project with and empty module, then copy/paste some of the code below into it,
to see what it does, and explore it by experimenting with (changing) it and
predicting what results from the changes. I always have an Eclipse folder/module
named "experiment" open for this purpose.

This lecture note is long (it is really three lectures), but the information is
not deep (for ICS-31/ICS-32 graduates). I hope this is all review, but there
are likely to be a few things that come up as new (or a few new perspectives
and connections of old material). Pay close attention to the terminology used
here, as I will use it (I hope consistently) over the entire quarter.

The voyage of discovery is not in seeking new landscapes but in having new eyes.
- M. Proust

------------------------------------------------------------------------------

Python in Four Sentences:

1. Names are bound to objects.
2. Everything that Python computes with is an object.
   (examples are instance, function, module, and class objects)
3. Every object has a namespace.
   (a dictionary that binds its internal names to other objects)
4. There are rules about how things work.

In some sense these four rules tell you nothing about Python, but in another
sense they are a tiny framework in which to interpret every idea in Python and
how Python works.

Every name appears in the namespace of some object (when we define names in a
module, for example, these names are appear in the module object's namespace);
and every name is itself bound to some object (names are bound when defined and
can be rebound with the = symbol).

Objects are the fundamental unit with which Python computes. For example...
  1) We can compute with int objects (instance objects from the int class) by
     using operators; for the in object bound to x by x = 1
     x = x + 1

  2) We can compute with function objects by calling them; for the function
     object bound to print,
     print(x)
   
  3) We can compute with module objects by importing them (and/or the objects
     bound to the names in their namespaces).
     import random			or     from random import randint
     x = random.randint(1,6)		       x = randint(1,6)

  4) We can compute with class objects by constructing instance objects and
     using the instances to call class methods.
     timer = Stopwatch()
     timer.start()

Rules determine how names are bound, how argument/parameter bindings work, how
operators compute, how control structures execute code, etc. This course is
designed to demystify how Python executes scripts and how you can better use its
features to write scripts.

------------------------------------------------------------------------------

Binding

The process of making a name refer to a value: e.g., x = 1 binds the name x to
the value 1, which is an object/instance of the int class; later we can bind x
to another value (possibly from another class) in another assignment: x = 'abc'.
We speak about "the binding (noun) of a name" to mean the value (such values
are always objects) that the name is currently associated with.

In Python, all instances, modules, functions, and classes are objects that have
a dictionary that stores its namespace: all its bindings. We will learn much
more about namespaces (and how to manipulate them) later in the quarter, when we
study classes in more detail.

Typically we illustrate the binding of a name to an object (below, x = 1) as
follows. We write the name over a rectangle, in which is the tail of an arrow
is inside: the arrow's head refers to a rounded-edge rectangle object labeled
by its type (here the class it is constructed from) and its value (inside).

  x          int
+---+	    (---)
| --+------>| 1 |
+---+	    (---)

Technically, if we we write x = 1 inside the module m, Python creates an object
for module m (we show all objects as rounded-edge rectangles) in which it puts
x, its box, and its binding: here, the name x is defined in module m and bound
to object 1. That is, we would more formally write the result of x = 1 in
module m as

    m
(---------)
|    x    |      int
|  +---+  |     (---)
|  | --+--+---->| 1 |
|  +---+  |     (---)
(---------)

Note that the del command in Python (e.g., del name) removes a name from the
namespace/dictionary of the object in which name is bound. Writing del x
inside module m would remove x and its box from m's namspace/dictionary.

Finally, the is operator in Python determines whether two references refer to
the same object; the == operator determines whether two references refer to
objects that have the same state. If a is b is True then a== b must be True
(because an object has the same state as itself).

If we write

  a = [0,1]
  b = [0,1]
  
then a is b is False and a == b is True: a nd b refer to two different list
objects, with the same state. Likewise, if we write

  a = [0,1]
  b = a

then a is b is True (and a == b is True): a nd b refer to the same list object.

------------------------------------------------------------------------------

statements vs expressions

Statement are executed to cause an effect (e.g., binding/rebinding a name or
producing output). Expressions are evaluated to compute a result (e.g.,
computing some formula). For example, the statement x = 1, when executed,
causes a binding of the name x to an object representing the integer 1. The
expression x+1, when evaluated, computes the an object representing the integer
2. Typically we write expressions in statements: two examples are x = x+1 and
print(x+1): both "do something" with the computed value (the first binds x to
it; the second prints it). The distinction between statements and expressions
is important in most programming languages. 

Control structures are considered statements in Python, but some constructs can
be used in control-structures/statements or in expressions. The following is a
conditional statement using if/else

  if x == None:
      y = 0
  else:
      y = 1

while the following is a definition statement including an conditional
expression using if/else

  y = (0 if x == None else 1)

We will discuss conditional statements vs. conditional expressions in more
detail later in this lecture note.

------------------------------------------------------------------------------

None:

None is a value (object/instance) of NoneType it is the only value of that type.
Sometimes None gets used as a default value for a parameter; sometimes it gets
used as a return value of a function: a Python function that terminates without
executing a return statement automatically returns the value None. If None shows
up as an unexpected result in your code, I'd look for a function whose return
value you forgot to specify (or whose return somehow didn't get executed).

------------------------------------------------------------------------------

pass:

pass is the simplest statement in Python; semantically, it means "do nothing".
Sometimes when we write statements, we aren't sure exactly which ones to write,
so we migh use pass as a placeholder until we write the actual statement we
need. Often, in tiny examples, we use pass as the meaning of a function.

  def f(x) : pass     or     def f(x) :
      	     	      	         pass

If you are ever tempted to write the first if statement below, don't; instead
write the second one, which is simpler: they are equivalent.

  if a in s:			# DON'T write this code
      pass
  else:
      print('a is not in s')


  if a not in s:		# Write this code instead; it is equivalent
      print('a is not in s')

------------------------------------------------------------------------------

Importing:

There are five import forms; you should know what each does, and start to think
about which is appropriate to use in any given situation. Note we will soon
learn EBNF and see that [...] means option and {...}  means repeat 0 or more
times, although this second form is sometimes written (...)*

"import module-name" form:
  1. import module-name{,module-name}
  2. import module-name [as alt-name] {,module-name [as alt-name]}

"from module-name import attr-name" form:
  1. from module-name import attr-name{,attr-name}
  2. from module-name import attr-name [as alt-name] {,attr-name [as alt-name]}
  3. from module-name import *

Above, alt-name is an alternative name, and attr-name is an attribute name
defined in the namespace of the module.

The "import module-name" forms import the names of modules (not their attribute
names). (1) bind each module-name to the object representing that imported
module-name. (2) bind each alt-name to the object representing its preceding
imported module-name.

The "from module-name import attr-name" forms don't import module-name, but
instead import names defined/bound inside module-name. (1) bind each attr-name
to the object bound to that attr-name in module-name. (2) bind each alt-name to
the object bound to the preceding attr-name in module-name. (3) bind each name
that is bound in module-name to the same object it is bound to in module-name.

Import (like an assignment, def, and class) creates a name (if that name is not
already in the namespace) and binds it to an object: the "import module-name"
form binds names to module objects; the "from module-name import attr-name"
form binds names to objects (instances, functions, modules, classes) defined
inside modules (so now two modules have names bound to the same objects).

The key idea as to which kind of import to use is to make it easy to refer to a
name but not pollute the name space of the module doing the importing with too
many names.

If a lot of different names in the imported module are to be used, or we want
to make it clear when an attribute name in another module is used, use the
"import module-name" form and then qualify the names when used: for example

  import random
  # use  random.choice(...), random.randint(...)

If the imported module-name is too large for using repeatedly, use an
abbreviaton by importing using an alt-name: for example

  import high_precision_math as hp_math
  # use  hp_math.sqrt(...)

If only one name (or a few names) are to be used from a module, use the form:

  from collections import defaultdict
  # use defaultdict(...)

Again, use alt-name to simplify either form, if the name is too large and
unwieldy to use. Such names are often very long to be clear, but awkward to use
many times at that length. Generally we should apply the Goldilocks principle:
name lengths shouldn't be too short (devoid of meaning) or too long (awkward to
read/type) but their length should be "just right".

We almost never write the * form of importing. It imports all the names defined
in module-name, and pollutes our namespace by defining all sorts of names we
may or may not use (and which might conflict with names we have already
defined). Better to explicitly import the names needed/used. Eclipse marks with
a warning any names that are imported but unused.

------------------------------------------------------------------------------

directly iterating over values in a list vs.
  using range to iterate over indexes of values in a list vs

We know that we can iterate (with a for loop) over ranges: e.g., if alist is a
list, we can write

alist = [5, 2, 3, 1, 4, 0]
for i in range(0,len(alist)):
    print(i)

Here i takes on the values 0, 1, ... , len(alist)-1 but not len(alist). The
code above prints all the values.

Often we want to iterate over the values in a list (alist) but don't need to
use its indexes at all: e.g., to print all the values in a list we can use the
loop

for x in alist:
    print(x)

which is much better (simpler, clearer) than the loop

for i in range(0,len(alist)):
    print(alist[i])

although both produce the same result. Generally, choose to write the simplest
loop possible for all your code. Sometimes you might write a loop correctly, but
then realize that you can write a simpler loop correctly. Sometimes (when
doing more complicated index processing) we need to iterate over indexes.

In many cases where using range is appropriate, we want to go from the low to
high value inclusively. I have written an iterator named irange (for inclusive
range) that we can import from the goody module and use like range.

from goody import irange
for i in irange(1,10):
    print(i)

prints the values 1 through 10 inclusive; range would print only 1 through 9.

------------------------------------------------------------------------------

Arguments and Parameters (and Binding): Terminology

Whenever we define a function, we specify the names of its parameters in its
function header (in parentheses, separated by commas). Whenever we call a
function we specify the values of its arguments (also in parentheses, separated
by commas). The defintion below

def f(x,y):
    return x**y

defines a function of two parameters: x and y. f(5,2*6) calls this function with
two arguments: the arguments 5 and 2*6 are evaluated and the values computed
from these arguments (5 and 12) are bound to their matching parameters. We will
discuss the details of argument/parameter binding below, but in a simple example
like this one, parameter/argument binding is like writing: x,y = 5,2*6 which
binds x to 5 and y to 12.

Sometimes we can use the parameter of a function as an argument to another
function call. If we define

def factorial_sum(a,b):
    return factorial(a) + factorial(b)

Here the parameters a and b of factorial_sum function are used as arguments in
the two calls to the factorial function.

It is important that you understand the distinction between the technical term
parameter and argument, and that calling a function binds the parameter names
to the argument values.

------------------------------------------------------------------------------

Function calls ... always include ()

Any time a reference to an object is followed by (...) it means to perform a
function call on that object (some objects will raise an exception if they do
not support function calls). While this is trivial for the functions that you
have been writing and calling, there are some interesting ramifications of this
simple rule. Run the following code

def double(x):
    return 2*x

def triple(x):
    return 3*x

def magnitude(x):
    return 10*x

Note that each def defines the name of a function and binds that name to the
function object that follows it.

If we wrote

f = double

then f would become a defined name bound to the same (function) object that the
name double is bound to. There is no (), so there is no function call. If we
then write

print(f(5))

Python would print 10, just as it would if we printed double(5), because f and
double refer to the same function object, and it makes no difference whether we
call that function object using f or double. The function call does not occur
until we use ().

Here is a more intersting example, but of exactly the same idea.

for f in [double, triple, magnitude]:
    print(f(5))

Here f is a variable that iterates through the values of a list (we could also
have used a tuple): each value in the list is a function object (the objects
referred to by the names double, triple, and magnitude). It prints the values
computed by calling each of these function objects with the argument 5. Note
that these functions are NOT called when creating the list (no parentheses
there!): the list is just built to contain references to these three functions:
again, their names are not followed by () so there is no function call.

Using the same logic, we could also write a dictionary whose keys are strings
and whose values are function objects, and then use a string as a key needed to
call the its associated function object.

fs = {'2x' : double, '3x' : triple, '10x' : magnitude}
print( fs['3x'](5) )

Here fs is a dictionary that stores keys that are strings and associates a
function object with each (there are no calls to functions when building the
dictionary-building in the first statement); we then can look up the function
associated with any key (here the key '3x') and then call the resulting
function (here fs['3x']) with the argument 5. Of course in the second statement
we use the () to call the function selected from the dictionary.

------------------------------------------------------------------------------

Global and Local Names

Names defined in a module are global definitions; names defined in a function
(and later names defined in a class) are local definitions. In a module, we can
refer to global names, but not any local names. In functions we can refer to
local or global names.

Let's start by looking at 

x = 1
print(x)

which prints 1. Here the module defines a global name x and prints the value
bound to that global name. Now lets look at

x = 1
def f():
    print(x)
f()
print(x)

which prints 1 and then 1. Here the module defines a global name x and a global
name f (the function, which uses the global name x). When we call f(), it prints
the value bound to the global name x. Then, returning to the module, it prints
the value bound to the global name x again.

Now lets look at

x = 1
def f():
    x = 2
    print(x)
f()
print(x)

which prints 2 and then 1. Here the module defines a global name x and a global
name f (the function, which defines a local name x). When we call f(), it binds
the local name x to 2 and then prints the value bound to the local name x. Then,
returning to the module, it prints the value bound to the global name x.

What is the primary difference between this example and th preceding one: When
printing x in the function f, Python first looks for a local name x, if it finds
one it uses its value; if it doesn't find a local name, it tries to find a
global name and uses its value.

Now lets look at

x = 1
def f():
    y = 2
    print(x,y)
f()
print(x)

which prints 1 2 and then 1. Here the module defines a global name x and a
global name f (the function, which defines a local name y). When we call f(),
it binds the local name y to 2 and then prints the value bound to the global
name x and the local name y. Then, returning to the module, it prints the value
bound to the global name x. So this example illustrate the use of a global and
local name.

If we replaced print(x) at the end of the module with print(x,y) Python would
raise a NameError exception because y is a local name defined only in the
function f. It is not defined in the module.

Finally, what if we wanted function f to not only print the original value of
the global name x, but also to CHANGE it to 2. We CANNOT do it as follows, but
the reason is a bit deep.

x = 1			# wrong code
def f():		# wrong code
    y = 2		# wrong code
    print(x,y)		# wrong code
    x = 2		# wrong code
f()   			# wrong code
print(x)		# wrong code

What happens when Python executes this code? Here the module defines a global
name x and a global name f (the function, which defines local names y and x).
When we call f(), it binds the local name y to 2 and then it TRIES to print the
value bound to the global name x and the local name y. But the local name x
has no binding yet, so it raises the UnboundLocalError exception.

----------
Note that if we put the x = 2 before the print

x = 1			# wrong code
def f():		# wrong code
    y = 2		# wrong code
    x = 2		# wrong code
    print(x,y)		# wrong code
f()   			# wrong code
print(x)		# wrong code

Python would print 2 2 and then print 1, executing without raising an exception
but still not solving our problem. It still defines x as a local name and binds
it to 2, now allowing the print to work, but still leaving the global name x
unchanged.
----------

We can change the value in the global name x by using a "global" declaration
inside f.

x = 1
def f():
    global x
    y = 2
    print(x,y)
    x = 2
f()
print(x)

Python would print 1 2 and then print 2 (thus changing the global name x).
Here the module defines a global name x and a global name f (the function,
which defines only a local name y; the global x declaration tells Python to use
the global name x inside f whenever x is used). When we call f(), it binds the
local name y to 2 and then it prints the value bound to the global name x and
the local name y. Then it changes the binding of the global name x to 2 (recall
because of the global x declaration, all uses of x inside f refer to the global
name x). Then, returning to the module, it prints the value bound to the global
name x, which is now 2.

In summary, we can always use a global name inside a function to find its value
without doing anything special, but if we want to rebind the global name to a
new value inside the function we must declare the name global in the function.

What do you think the following code will do? Notice that is similar to the code
above, but it (a) does not define a global name x before defining f and (b)
omits the print statement.

def f():
    global x
    y = 2
    x = 2
f()
print(x)

Also can you explain what would happend if the print statment were restored,
between the statements x = 2 and y = 2.

Bottom Line: You should know how global names are found/used inside functions,
although typically no global names should be used: all information that a
function uses should be passed into the function via its parameters.

------------------------------------------------------------------------------

Function calls returning references to function objects and the LEGB rule

Look at the following function named bigger_than, which is a function of one
parameter. Inside, it defines a local function named test which also has one
parameter, then the bigger_than function returns a reference to the test
function object that it defines. Have you seen functions that return functions
before? This is powerful programming feature.

def bigger_than(c) :
    def test(x) :
        return x > c
    return test

Note that the inner function (test) can refer to global names and any local
names defined in the outer function(bigger_than): here test refers to its own
local parameter name (x) and to the parameter name (c) defined if the
bigger_than function. Generally when Python looks up the binding of any name,
it uses the LEGB rule (which generalizes what we learned above):

  (1) Look for a Local name (parameter/local variable)
  (2) Look for the name in an Enclosing function
  (3) Look for a Global name (defined in the module outside the function)
  (4) Look for a name imported automatically from the Builtins module.

Now, we can write the following

old     = bigger_than(60)
ancient = bigger_than(90)
print (old(10), old(70), old(90), ancient(70), ancient(95))

which prints

False True True False True

The first two assignments above each bind a name (old and ancient) to the
function object that is returned from calling bigger_than. Then we call each
function a few times printing the results above.

In fact, we even could even have written something like

print ( bigger_than(60)(70) )

We know that bigger_than(60) calls bigger_than with the argument 60, which
returns a result that is a reference to its inner function; by writing (70)
after that we are again just calling that inner function object, the one
bigger_than(60) returned, using the argument 70.

Note that

def f(x):
    return 2*x

is really just creating a name f and binding it to a function object. So

    def test(x) :
        return x > c

binds a function object to the local name test. And

    return test

returns the function object currently bound to test (which remembers what value
c has in the enclosing scope, even after test is returned).

Note the difference between the following, which both print 6.

x = f(3)
print(x)

and 

g = f
print(g(3))

A large part of this course deals with understanding functions better, including
but not restricted to function calls.

------------------------------------------------------------------------------

Functions vs Methods

Functions are typically called f(...) while methods are called on objects like
o.m(...). Think of x ='candide' followed by calling print(x.replace('a','b'))

In reality, a method call is just a special syntax to write a function
call. The special "argument" o (normally arguments are written inside the
parentheses) prefixes the method name. Functions and methods are related by
what I call "The Fundamental Equation of Object-Oriented Programming."

  o.m(...)     =     type(o).m(o,...)

On the right side
  1) type(o) returns a reference to the class object o was constructed from.
  2) .m means call the function m declared in that class: look for def m(...)
       in the class
  3) pass o as the first argument to m: recall, for defining methods in classes
       we write def m(self, ....)

How well do you understand self (or yourself, for that matter)? This equation
is the key. I believe a deep understanding of this equation is the key to
clarifying many aspects of object-oriented programming in Python (whose objects
are constructed from classes). Just my two cents. But we will often return to
this equation. I've never seen any books that talk about this equation
explicitly.

Oh, by the way, I must say that this equation is not completely true. As we will
later see: (a) if m is in the object's namespaces, it will be called direclty,
and (b) when we learn about class inheritance, the inheritance hierarcy of a
class provides other classes in which to look for m. But this equation is so
simple and clear (once you understand it) and useful for tons of examples, it
is worth memorizing, even if not completely accurate.

------------------------------------------------------------------------------

Parallel/Tuple Assignment (aka sequence unpacking)

Note that we can write code like the following: here both x,y and 1,2 are
implicit tuples, and we can unpack them as follows

x,y = 1,2

In fact, you can replace the left hand side of the equal sign by either (x,y) or
[x,y] and replace the right hand side of the equal sign by either (1,2) or [1,2]
and x gets assigned 1 and y get assigned 2: even (x,y) = [1,2] works.

In most programming languages, to exchange the values of two variables x and y
we write three assignments (can you prove that writing just x = y followed by
y = x fails to exchange these values?):

temp = x
x    = y
y    = temp

In Python we can write this code using one sequence unpacking assignment

x,y = y,x

Python computes the values on the right (1 and 2 from the top) and then stores
2 in x and 1 in y. This is also called parallel assignment or sequence
unpacking assignment. Note that x,y = 1,2,3 and x,y,z = 1,2 both raise
ValueError exceptions, because there are different numbers of name and values
to assign to them.

If we define a function that returns a tuple

def reverse(a,b) :
    return (b,a)    # we could also write just return b,a

we can also write x,y = reverse(x,y) to also exchange these values. Finally, we
can use unpacking in for loops, and write the following for loop to print each
triple in the list.

for i,j,k in [(1,2,3), (4,5,6), (7,8,9)]:
    print (i,j,k)

It is assigning i, j, and k the three values in each 3-tuple in the list that
the for loop is iterating over. We will see more about such assignments when 
iterating though dictionaries. A preview is

for k,v in d.items():  #d is any dictionary
    print(k,v)

which prints each key and its associated value for each item (each key/value
association) that we are iterating through in a dictionary.

------------------------------------------------------------------------------ 

lambda:

Lambdas are used in expressions where we need a very simple function. Instead
of defining a full function (with a def), we can just use a lambda: after the
word lambda comes its parameters separated by commas, then a colon followed by
a single expression that computes the value of a lambda (no return needed, and
the function cannot include control structures, not even a sequence of 
statements).

Writing ...(lambda x,y : x+y)... in some context

Is just like first defining

def simple_f(x,y):
    return x+y

and then writing ...simple_f... in the same context

A lambda is an unnamed function object. For example, we can also write the
following code, whose first line binds to the name f the lambda/function
object, and whose second line calls the lambda via the name.

f = lambda x,y : x+y  # lambdas have one expression after : without a return
print(f(1,3))

and Python will print 4. I often put lambdas in parentheses, to more clearly
denote the lambda, for example writing

f =  (lambda x,y : x+y)

We could then write code code above without f, writing just

print( (lambda x,y : x+y)(1,3) )

In my prompt module, there is a function called for_int that has a parameter
that specifies a function that the int value must satisfy, to be returned by
the prompt (otherwise the for_int function prompts again, for a legal value).
That is, we pass the function object to prompt_for_int, which calls the function
on the value the user enters to the prompt, to verify that the function returns
True for that value.

So the following code fragment is guaranteed to store a value between 0 to 5
inclusive in the variable x.

import prompt
x = prompt.for_int('Enter a value in [0,5]', is_legal = (lambda x : 0<=x<=5))
print(x)

In the section below, we will see how lambdas are used simply when sorting
lists (or iterating through data structures according to an ordering function).

Again, I often put lambdas in parentheses for clarity: see the prompt.for_int
example above.

There are certain places where they are required: calling g(1,(lambda x : x),3)
requires the lambda to be in parenthese, because without the parentheses it
would read as g(1,lambda x : x,3) and Python would not think that 3 was a third
argument to function g: it would instead interpret the body of the lambda a x,3
meaning return a 2-tuple with x followed by 3.

------------------------------------------------------------------------------ 

sort(a list method)/sorted (an iterator)
  and their key and reverse parameters

The sort function can be applied to lists, and the sorted iterator can apply to
any iterable (e.g., lists, tuples, sets, dict). If votes is the list of 2-tuples
below, we can execute the following code

votes = [('Charlie', 20), ('Able', 10), ('Baker', 20), ('Dog', 15)]
votes.sort()
for c,v in votes:
    print('Candidate',c,'got',v,'votes')
print(votes)

The call votes.sort() sorts the list (mutates it); then the for loop prints the
information in the list (which is now sorted, so it prints sorted); when we
print the votes list at the end, we see the list has been sorted. Contrast this
with the following.

votes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]
for c,v in sorted(votes):
    print('Candidate',c,'got',v,'votes')
print(votes)

Here we never sort/mutate the list. Instead we use the sorted iterator to print
the information in the list in sorted form, but when we print the votes list at
the end, we see the list remained unchanged The sorted iterator makes a copy of
its parameter list, sorts the copy, and then iterates over the sorted copy, but
does not change the original list it operates on.

If we were going to print some list in a sorted form many times, it would be
more efficient to sort it once and then just just the regular iterator. But if
we needed to keep the list in a certain order and/or didn't care too much about
time (milliseconds) we would not sort/mutate the list and use the sorted
iterator instead to process it in a sorted order.

Note that if we change votes to a dict

votes = {'Charlie': 20, 'Able': 10, 'Baker': 20, 'Dog': 15}

we cannot write votes.sort(), but we can still use the sorted iterator on it.
In fact, we cannot sort tuples (they are immutable), sets (they have no order,
which actually allows them to operate more efficiently; we'll learn why later
in the quarter), or dicts (they have no order, which allows them to operate more
efficiently; ditto).

But we can use the sorted iterator on all three: Python creates a temporary
list from the tuple/set/dict, then sorts that list, and iterates over it. Here
is an example of how the sorted iterator processes votes as a dict. Writing
sorted(votes) is the same as writing sorted(votes.keys()) which produces and
iterates over a sorted list of the dict's keys.

votes = {'Charlie' : 20, 'Able' :  10, 'Baker' : 20, 'Dog' : 15}
for c in sorted(votes): # same meaning as for c in sorted(votes.keys())
    print('Candidate',c,'got',votes[c],'votes')
print(votes)

Well, this is the "normal" way to write this. We can also iterate over sorted
"items" as follows (the difference is in the for loop and print). We will
examine more about dicts and their different iterators later in this lecture.

votes = {'Charlie' : 20, 'Able' :  10, 'Baker' : 20, 'Dog' : 15}
for c,v in sorted(votes.items()):
    print('Candidate',c,'got',v,'votes')
print(votes)

Notice the print doesn't access votes[c] to get the votes, that is the second
item in each tuple being iterated over using .items(). This is because
votes.items() is like a list of 2-tuples, each containing each key and its
associated value. The order that these 2-tuples appear in the list is random,
but using the sorted iterator ensures the keys are examined in order.

So, how does sort/sorted work? How do they know how to compare the values they
are sorting? There is a standard way, but we can also use the key and reverse
parameters (which must be used with their names, not positionally) to tell
Python how to sort. The reverse parameter is simpler, so let's look at it first;
writing sorted(votes,reverse=True) sorts but in the reverse order
(reverse=False is like not specifying reverse at all). Try it in the code above.

What sort is doing is comparing each value in the list to the others using the
standard meaning of <. You should know how Python compares str values, but how
does Python compare whether one tuple is less than another? Or whether one list
is less than another? The algorithm in analagous to strings, so let's first
re-examine strings. The ordering, by the way, is called lexicographic ordering,
and also dictionary ordering (related to the order words appear in dictionaries,
but unrelated to Python dicts).

---------------

Comparing Strings in Python:

String comparison: x to y (high level:

Find the first/minimum index i such that the ith character in x and y are
different (or, x[i] != y[i]). If that character in x is less than that
character iny (by the standard ASCII table) then x is less than y; if that
character in x is greater than that character in y then x is greater than y;
if there is no such different character, then x compares to y as x's length
compares to y's (either less than, equal or greater than).

So how do we compare x = 'aunt' and y = 'anteater'? The first/minimum i such
that the characters are different is 1: x[1] is 'u' and y[1] is 'n'; 'n' is
less than 'u' so x > y (or y < x).

How do we compare x = 'ant' and y = 'anteater'? There is no first/minimum i
such that the characters are different; len(x) < len(y) so x < y. The word
'ant' appears in a real/book dictionary before 'anteater'.

Finally, how do we compare x = 'ant' and y = 'ant'? There is no first/minimum i
such that the characters are different; len(x) == len(y) so x == y. I show this
example, which is trivial, just to be complete.

See the Handouts(General) webpage showing the ASCII character set, because
there are some suprises. You should memorize that the digits and lower/upper
case letters compare in order, and all digts < all upper-case letters < all
lower-case letters. So 'HUGE' < 'tiny' is True because 'H' is < 't' (all
upper-case letters have smaller ASCII values than any upper-lower case letters).
Likewise, 'Aunt' < 'aunt' because 'A' < 'a'. We can use the upper() method (as
in x.upper() < y.upper()) to do a comparison that ignores case.

---------------

Back to tuples (or lists). We basically do the same thing. We look at what is
in index 0; if different, then the tuples compare in the same way as the values
in index 0 compare; if the same, we keep going until we find a difference and
compare the tuples the same way that the differences compare; if there are no
differences the tuples compare the same way their lengths compare. So
('UCI', 100) < ('UCSD', 50) is True because at index 0, 'UCI' is < 'UCSD'
because 'I' < 'S'. Whereas ('UCI', 100) < ('UCI', 200) is True because the
values at index 0 are the same ('UCI' == 'UCI'), so we go to index 1, where we
find 100 < 200. Finally, ('UCI', 100) < ('UCI', 100, 'extra') is True because
the values at index 0 are the same ('UCI' == 'UCI') and the values at index 1
is the same (100 == 100), and the last tuple has a larger length.

Remember the code from above.

votes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]
for c,v in sorted(votes):
    print('Candidate',c,'got',v,'votes')
print(votes)

The reason the values come out in the order they do in the code above is
because the names that are first index in each 2-tuple ensure the tuples are
sorted alphabetically. Python never gets to looking at the second value in each
tuple, because the first values (the candidate names) are always different.

Now, what if we don't want to sort by the natural tuple ordering. We can
specify a key function that computes a value for every tuple, and the computed
values are used for comparison, not the original values themselves. These are
the so called "keys" for comparison.

So, the by_vote_count function below takes a tuple parameter and returns only
the second value in the tuple (recall indexes start at 0) for the key on which
Python will compare. For the argument tuple ('Baker' ,20) by_vote_count returns
20.

def by_vote_count(t):
    return t[1]            # remember t[0] is the first.

So, when we sort with key=by_vote_count, we are telling sorted to determine the
order of values by calling the by_vote_count function on each value: so in this 
call of sorted, we are comparing tuples based solely on their vote part. So
writing

votes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]
for c,v in sorted(votes, key=by_vote_count):
    print('Candidate',c,'got',v,'votes')

produces 

Candidate Able got 10 votes
Candidate Dog got 15 votes
Candidate Charlie got 20 votes
Candidate Baker got 20 votes

First, notice I didn't CALL by_vote_count (no parentheses) I just passed its
function object to the key parameter in sort. Inside the sorted iterator, it 
calls the by_vote_count's function object automatically where needed to compare
two 2-tuples to determine in which order to iterate over these values.

Also, because Charlie and Baker both received the same number of votes, they
are at the bottom, in any order.

Notice that the values are printed in ascending votes; generally for elections
we want the votes to be descending, so we can combine using key and reverse
(with reverse=True) in the call to the sorted iterator.

votes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]
for c,v in sorted(votes, key=by_vote_count, reverse=True):
    print('Candidate',c,'got',v,'votes')

which produces 

Candidate Charlie got 20 votes
Candidate Baker got 20 votes
Candidate Dog got 15 votes
Candidate Able got 10 votes

Now, rather than define this simple by_vote_count function, we can use a lambda
instead, and write the following.

...
for c,v in sorted(votes, key=(lambda t : t[1]), reverse=True):
    ...

So, now we don't have to write that extra by_vote_count function. Of course, if
we did write it, we could reuse it wherever we wanted, instead of rewriting the
lambda (but the lambdas are pretty small). So, know how to use functions and
lambdas; we'll talk more about the judgement needed to determine when to use
each later in the quarter.

Another way to sort in reverse order (for integers) is to use the "negate" trick
illustrated below.

...
for c,v in sorted(votes, key=lambda t : -t[1] ):
    ...

Here we have negated the vote count part of the tuple, and removed reverse=True.
So it is sorting from smallest to largest, but by the negative of the vote
values (because that is what key says to do). It is using -20, -10, -20, and -15
to sort. So the biggest vote count corresponds to the smallest negative number
(so that tuple will appear first). The tuples appear in the order specified by
the key functions: -20, -20, -15, -10 (smallest to largest).

Finally, typically when multiple candidates are tied for votes, we print their
names together (because they all have the same number of votes) but also in
alphabetical order. We do this in Python by specifying a key function that
returns a tuple in which the vote count is checked first and sorted in
descending order; and only if they are tied will the names be checked and
sorted in ascending order. Because we want the tuples in decreasing vote
counts but increasing names, we cannot use reverse=True; we need to resort to
the "negation" trick above and write

votes = [('Charlie', 20), ('Able', 10), ('Baker' ,20), ('Dog', 15)]
for c,v in sorted(votes, key=lambda t : (-t[1],t[0]) ):
    print('Candidate',c,'got',v,'votes')

So it uses the 2-tuples (-20, 'Charlie'), (-10, 'Able'), (-20, 'Baker'), and
(-15, 'Dog') when comparing, and by what we have learned

(-20, 'Baker') < (-20, 'Charlie') < (-15, 'Dog')


(-10, 'Able')
which produces 

Candidate Baker got 20 votes
Candidate Charlie got 20 votes
Candidate Dog got 15 votes
Candidate Able got 10 votes

Note that the lambda in the key ensures Python compares ('Charlie', 20) and
('Dog', 15) as if they were (-20, 'Charlie') and (-15, 'Dog') so the first
tuple will be less and appear earlier (the one with the highest votes has the
lowest negative votes). And when Python compares ('Charlie', 20) and
('Baker' ,20) as if they were (-20, 'Charlie') and (-20, 'Baker') so the second
tuple will be less and appear earlier (equal votes and 'Baker' < 'Charlie').

You now have a good tool bag for sorting various types of information.

------------------------------------------------------------------------------

The print function

Notice how the sep and end parameters in print help control how the printed
values are separated and what is printed after the last one. Recall that print
can have any number of parameters (we will see how this is done soon), and it
prints the str(...) of each parameter. By default, sep=' ' (space) and
end='\n' (newline). So the following

print(1,2,3,4,sep='--',end='/')
print(5,6,7,8,sep='x',end='**')

prints

1--2--3--4/5x6x7x8**

Also recall that all functions return a values. The print function returns the
value None.

Sometimes we use sep='' to control spaces more finely. In this case we must put
all the spaces in ourselves. Still, other times we can catenate values together
into one string (which requires us to explicitly use the str function).

x = 10
print('Your answer of '+str(x)+' is too high'+'\nThis is on the next line')

Note the use of the "escape" sequence \n to generate a new line.

Finally, we can also use the very general-purpose .format function. This
function is illustrated in Section 6.1.3 in the documentation of The Python
Standard Library.

print('Your answer of {x} is too high\nThis is on the next line'.format(x=10))

------------------------------------------------------------------------------

String/List/tuple (SLT) slicing:

SLTs are indexed starting at index 0, and going up to but not including the
length of the SLT.

1) Indexing: We can index an SLT by writing SLT[i], where i is positive and in
   the range 0 to len(SLT)-1 inclusive, or i is negative and i is in the range
  -len(SLT) to -1 inclusive: SLT[0] is the first index, SLT[-1] is the last.

2) Slicing: We can specify a slice by SLT[i:j] which includes SLT[i] followed
   by SLT[i+1], ... SLT[j-1]. Slicing a string produces another string,
   slicing a list produces another list, and slicing a tuple produces another
   tuple. The resulting structures has j-i elements (or 0 if that number is
   <= 0); this formula works for positive and negative values.

s = 'abcde'
x = s[1:3]
print (x) # prints 'bc' which is 3-1 = 2 values
x = s[-4:-1]
print (x) # prints 'bcd' which is -1-(-4) = 3 values

   likewise

s = ('a','b','c','d','e')
x = s[1:3]
print (x) # prints ('b','c') which is 3-1 = 2 values
x = s[-4:-1]
print (x) # prints ('b','c', 'd') which is -1-(-4) = 3 values

   s[:i] is index 0 up to but not including i (can be positive or negative)
   s[i:] is index i up to and including the last index; so s[-2:] is the last
         two.

3) Slicing with stride: We can specify a slice by SLT[i:j:k] which includes
   SLT[i] followed by SLT[i+k], SLT[i+2k] ... SLT[j-1]. This follows the rules
   for slicing too, and allows negative numbers for indexing.

s = ('a','b','c','d','e')
x = s[::2]
print (x) # prints ('a','c','e')
s = ('a','b','c','d','e')
x = s[1::2]
print (x) # prints ('b','d'')

x = s[3:1:-1]
print (x) # prints ('d','c')
x = s[-1:-4:-1]
print (x) # prints ('e','d','c')

------------------------------------------------------------------------------

Conditional statement vs. Conditional expression

Python has an if/else statement, which is a conditional statement. It also has a
conditional expression that uses the keywords if and else, which while not as
generally useful, sometimes is exactly the right tool to simplify a task. A
conditional statement uses a boolean expression to decide which other statement
to execute; a conditional expression uses a boolean expression to decide which
other expression to evaluate: its value is the value of the conditional
expression.

The form of a conditional expression is

  resultT if test else resultF

This says, the expression evaluates to the value of resultT if test is True
and the value of resultF if test is False; first it evaluates test, and then
evaluates either resultT or resultF (but only one, not the other) as necessary.
Like other short-circuit operators in Python (do you know which?) it evaluates
only the subexpressions it needs to evaluate to determine the result.

I often put conditional expresions inside parentheses for clarity (as I did for
lambdas). See the examples below.

Here is a simple example. We start with a conditional statement, which always
stores a value into min: either x or y depending on whether x <= y. Note that
regardless of the test, min is bound to a value.

  if x <= y:
      min = x
  else:
      min = y

We can write this using a simpler conditional expression, capturing the fact
that we are always storing into min, and just deciding which value to store.

  min = (x if x <= y else y)

Not all conditional statements can be converted into conditional expressions;
typically only simple ones can, but doing so simplifies the code even more.
So attempt to use conditional expression, but use good judgement after you see
what the code looks like.

Here is another example; it always prints x followed by some message

  if x % 2 == 0:
      print(x,'is even')
  else:
      print(x,'is odd')

We can rewrite it as as calling print with a conditional expression inside
deciding what string to print at the end.

      print(x, ('is even' if x%2 == 0 else 'is odd'))

We can also write it as a one argument print:

      print(str(x) +(' is even' if x%2 == 0 else ' is odd'))

------------------------------------------------------------------------------

The else: block-else option in for/while loops

For and while looping statements are described as follows. The else: block-else
is optional, and not often used. But we will explore its meaning here.

for_statement   <= for index(es) in iterable:
                       block-body
                   [else:
                       block-else]

while_statement <= while <bool-expression>:
                       block-body
                   [else:
                       block-else]

Here are the semantics of else: block-else.

   If the else: block-else option appears, and the loop terminated normally,
   (not with a break statement) then execute block-else.

Here is an example that makes good use of the else: block-else option. This
code prints the first/lowest value (looking at 0 to 100 inclusive) for which
the function special_property returns True (and then breaks out of the loop);
otherwise it prints that no value in this range had this property: so it prints
exactly one of these two messages. Note you cannot run this code, because there
is no special_property function: I'm using it for illustration only.

for i in irange(100):
    if special_property(i):
        print(i,'is the first value with the special property')
        break
else:
    print('No value in the range had the special property')

Without the else: block-else option, the simplest code that I can write that has
equivalent meaning is as follows.

found_one = False
for i in irange(100):
    if special_property(i):
        print(i,'is the first with the special property')
        found_one = True
        break
if not found_one:
    print('No value in the range had the special property')

This solution requires an extra name (found_one), an assignment to reset the
name, and an if statement. Although I came up with the example above, I have
not used the else: block-else option much in Python. Most programming languages
that I have used don't have this special feature, so I'm still exploring its
usefulness. 

Can you predict what would happen if I removed the break statement in the
bigger code above?

------------------------------------------------------------------------------

Argument/Parameter Matching (leaves out **kargs, talked about later)

Let's explore the argument/parameter matching rules. First we classify
arguments and parameters, according the options they include

Arguments
  positional argument: an argument not preceded by name= option
  named      argument: an argument preceded by name= option

Parameters
  name-only parameter       : a parameter with no default value
  default-argument parameter: a parameter including a default argument value

When Python calls a function, it defines every parameter name in the
function's header, and binds to each (just like an assignment statement) the
argument value object matching that parameter's name. In the rules below, we
will learn exactly how Python matches arguments to parameters according to three
criteria: positions, parameter names, and default arguments for parameter
names.

Here are Python's rules for matching arguments to parameters.
The rules are applied in this order (e.g., once you reach M3 we
cannot go back to M1).

M1. Match positional argument values in the call sequentially to the
    parameters named in the header's corresponding positions (both name-only
    and default-argument parameters are OK). Stop when reaching any named
    argument in the call or the * parameter in the header.

M2. If matching a * parameter in the header, match all remaining positional
    argument values to it. Python creates a tuple that stores all these
    arguments. The parameter name (typically args) is bound to this tuple.

M3. Match named-argument values in the call to their like-named parameters
    in the header (both name-only and default-argument parameters are OK)

M4. Match any remaining default-argument parameters in the header, un-
    matched by rules M1 and M3, with their specified default arguments.

M5. Exceptions: If at any time (a) an argument cannot match a parameter
    (e.g., a positional-argument follows a named-argument) or (b) a parameter
    is matched multiple times by arguments; or if at the end of the process
    (c) any parameter has not been matched, raise an exception: SyntaxError
    for (a) and TypeError for (b) and (c). These exceptions report that the
    function call does not correctly match its header.

(When we examine a **kargs as a parameter, we will learn what Python does when
there are extra named arguments in a function call: names besides those of
parameters: preview: it puts all remaing named arguments in a dictionary, with
their name as the key and their value associated with that key). The parameter
name (typically kargs) is bound to this dictionary.

When this argument-parameter matching process if finished, Python defines,
(in the function's namespace), a name for every parameter and binds each to
the argument it matches using the above rules. Passing parameters is similar
to performing a series of assignment statements between parameter names and
their argument values.

If a function call raises no exception, these rules ensure that each parameter
in the function header matches the value of exactly one argument in the
function call. After Python binds each parameter name to its argument, it
executes the body of the function, which computes and returns the result of
calling the function

Here are some examples:

def f(a,b,c=10,d=None): pass
def g(a=10,b=20,c=30) : pass
def h(a,*b,c=10)      : pass

Call              | Parameter/Argument Binding (matching rule)
------------------+--------------------------------------------
f(1,2,3,4)	  | a=1, b=2, c=3, d=4(M1)
f(1,2,3)	  | a=1, b=2, c=3(M1) d=None(M4)
f(1,2)		  | a=1, b=2(M1) c=10, d=None(M4)
f(1)		  | a=1(M1) c=10, d=None(M4), TypeError(M5c:b)
f(1,2,b=3) 	  | a=1, b=2(M1) b=3(M3), TypeError(M5b:b)
f(d=1,b=2)	  | d=1, b=2(M3) c=10(M4), TypeError(M5c:a)
f(b=1,a=2)	  | b=1, a=2(M3) c=10, d=None(M4)
f(a=1,d=2,b=3)	  | a=1, d=2, b=3(M3), c=10(M4)
f(c=1,2,3)	  | c=1(M3), SyntaxError(M5a:2)
g()		  | a=10, b=20, c=30(M4)
g(b=1)		  | b=1(M3), a=10, c=30(M4)
g(a=1,2,c=3)	  | a=1(M3), SyntaxError(M5a:2)
h(1,2,3,4,5)	  | a=1(M1), b=(2,3,4,5)(M2), c=10(M4)
h(1,2,3,4,c=5)    | a=1(M1), b=(2,3,4)(M2), c=5(M4)
h(a=1,2,3,4,c=5)  | a=1(M3), SyntaxError(M5a:2)
h(1,2,3,4,c=5,a=1)| a=1(M1), b=(2,3,4)(M2), c=5(M3), TypeError(M5b:a)

Here is a real but simple example of using *args, showing how the max function
is implememented in Python; we dont' really need to write this function because
it is in Python already, but here is how Python does it. We will cover raising
exceptions below, so don't worry about that code 

def max(*args) :     	   # Can refer to args inside; it is a tuple of values
    if len(args) == 0:
        raise TypeError('max: expected >=1 arguments, got 0')
    answer = args[0]
    for i in args[1:]:
        if i > answer:
            answer = i
    return answer
print(max(3,-4, 2, 8))

Here is another real example of using *args, where I show how the print function
is written in Python. myprint calls a very simple version of print, just once at
the end, to actually print the string that it builds from args along with sep
and end; it prints the same thing the normal print would print with the same
arguments. Notice the use of the conditional if in the first line, to
initialize s to either '' or the string value of the first argument

def myprint(*args,sep=' ',end='\n'):
    s = (str(args[0]) if len(args) >= 1 else '') # handle 1st (if there) special
    for a in args[1:]:	 	      	     	 # all others with sep
        s += sep + str(a)
    s += end					 # end at the end
    print(s,end='')				 # print the string

myprint('a',1,'x')			# prints a line
myprint('a',1,'x',sep='*',end='E')	# prints a line but stays at end
myprint('a',1,'x')			# continues at end of previous line

These print.

a 1 x
a*1*xEa 1 x

------------------------------------------------------------------------------

Iterators and Iterable to Construct Data

List, Tuples, Sets:

Iterators (for loops) allow us to iterate through all the components of
iterable data. We can even iterate over strings: iterating through their
individual characters. We will study iterator protocols in detail, both the
special iter/__iter__ and next/__next__ methods in classes, and generators
(which are very very similar to functions, with a small but powerful twist),
later in the quarter. Both will improve our understanding of iterators and
also allow us to write our own iterators.

Certainly we know about using "for" loops and iterable data (as illustrated by
lots of code above). What I want to illustrate here is how easy it is to
create lists, tuples, and sets from anything that is iterable by using the
list, tuple, and set constructors (we'll deal with dict constructors later in
this review). For example, in each of the following the constructor for the
list/tuple/set objects iterates over the string argument to get the 1-char
strings that become the values in the list/tuple/set object.

l = list ('radar') then l is ['r', 'a', 'd', 'a', 'r']
t = tuple('radar') then t is ('r', 'a', 'd', 'a', 'r')
s = set  ('radar') then s is {'a', 'r', 'd'} or {'d', 'r', 'a'} or ...

Note that lists/tuples are ORDERED, so whatever the iteration order of their
argument is, the values in the list/tuple will be the same order. Contrast
this with sets, which have (no duplicates and) no special order. In fact Python
will print the set created above as {'r', 'a', 'd'} but set('abcde') prints as
{'c', 'b', 'a', 'e', 'd'}.

Likewise, since tuples/sets are iterable, we could compute a list from a tuple
or a list from a set. Using l, t, and s from above...

list(t) which is ['r', 'a', 'd', 'a', 'r']
list(s) which is ['r', 'a', 'd']

Likewise we could create a tuple from a list/set, or a set from a list/tuple.
All the constructors handle iterable data, producing a result by iterating over
their argument.

Program #1 will give you lots of experience with these data types and when and
how to use them. The take-away now is it is trivial to convert from one of these
objects to another, because the constructors for their classes all allow
iterable values as their arguments, and all these data types (and Strings as
well) are iterable.

Dictionaries:

Before leaving this topic, we need to look at how dictionaries fit into the 
notion of iterable. There is not ONE way to iterate through dictionaries, but
there are actually THREE ways to iterate through dictionaries: by keys, by
values, and by items (each item a 2-tuple with a key folowed by its associated
value).  Each of these is summoned by a method name for dict, and the methods
are named the same: keys, values, and items.

So if we write the following to bind d to a dict (we will discuss this "magic"
constructor soon)

d = dict(a=1,b=2,c=3,d=4,e=5) # the same as {'a':1,'b':2,'c':3,'d':4,'e':5}

Then we can create lists of three aspects of the dict:

list(d.keys  ()) is like ['c', 'b', 'a', 'e', 'd']
list(d.values()) is like [3, 2, 1, 5, 4]
list(d.items ()) is like [('c', 3), ('b', 2), ('a', 1), ('e', 5), ('d', 4)]

Note that like sets, dicts are NOT ORDERED: in the first case we get a list
of the keys; in the second a list of the values; in the third a list of tuples,
where each tuple contains one key and its associate value. But these can appear
in ANY ORDER.

Note that the keys in a dict are always unique, but there might be duplicates
among the values: try the code with d = dict(a=1,b=2,c=1). Items are unique
because they contain keys (which are unique).

Also note that if we iterate over a dict without specifying how, it is
equivalent to specifyihg d.keys(). That is

list(d) is the same as list(d.keys()) which is ['a', 'c', 'b', 'e', 'd']

One way to construct a dict is to give it an iterable, where each value
is either a 2-tuple or 2-list: a key followed by its value. So, we could
have written any of the following to initialize d:

d = dict( [['a', 1], ['b', 2], ['c', 3], ['d', 4], ['e', 5]] ) #list of  2-list
d = dict( [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)] ) #list of  2-tuple
d = dict( (['a', 1], ['b', 2], ['c', 3], ['d', 4], ['e', 5]) ) #tuple of 2-list
d = dict( (('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)) ) #tuple of 2-tuple

or, even (a tuple that has 2-tuples and 2-lists in it)

d = dict( (('a', 1), ['b', 2], ('c', 3), ['d', 4], ('e', 5)) )

or even (a set of 2-tuples; we cannot have a set of 2-list (see hashable below)

d = dict( {('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)} )

The dict argument must be iterable, and each value in the iterable must have 2
values (e.g., a 2-list or 2-tuple) that represent a key followed by its
associated value.

Finally, if we wanted to construct a dict using the keys/values in another
dict, here are two easy ways to do it

d_copy = dict(d))

or

d_copy = dict(d.items())

------------------------------------------------------------------------------

Sharing/Copying:  is vs. ==

It is important to understand the fundamental difference between two names
sharing an object (bound to the same object) and two names referring/bound to
two "copies of the same object". Note that if we mutate a shared object, both
names "see" the change: both are bound to the same object which has mutated.
Not so if they refer to different copies of the same object.

Note the difference between the Python operators is and ==. The first asks
whether two references/binding are to the same object (this operator is called
the object-identity operator); the second asks only whether the two objects
store the same values. See the different results produced for the example
below. Also note that if x is y is True, then x == y must be True too (why?).

For example, compare execution of the following scripts: the only difference
is the second statement in each: y = x vs. y = list(x)

x = ['a']
y = x		# Critical: y and x share the same reference
print('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)
x [0] = 'z'	# Mutate x (could also append something to it)
print('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)

This prints
x: ['a'] y: ['a'] x is y: True x == y: True
x: ['z'] y: ['z'] x is y: True x == y: True

x = ['a']
y = list(x)	# Critical: y refers to a new list with the same contents as x
print('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)
x [0] = 'z'	# Mutate x (could also append something to it: x+)
print('x:',x,'y:',y,'x is y:',x is y,'x == y:',x==y)

This prints
x: ['a'] y: ['a'] x is y: False x == y: True
x: ['z'] y: ['a'] x is y: False x == y: False

Finally there is a copy module in Python that defines a copy function: it
copies some iterable without us having to specify a constructor like list, set,
tuple, or dict.

So we can import it as: from copy import copy

Assuming x is a list, we can replace y = list(x) by y = copy(x).
Likewise, if x is a ditc we can replace y = dict(x) by y = copy(x)

How is y = list( (1,2,3) ) different from y = copy((1,2,3))?

We could also just: import copy (the module) and then write y = copy.copy(x)
but it is clearer in this case to write from copy import copy.
  
------------------------------------------------------------------------------

Hashable vs. Mutable and how to Change Things:

Python uses the term Hashable, which has the same meaning as immutable. So
hashable and mutable are OPPOSITES: You might see this message relating to
errors when using sets with UNHASHABLE values or dicts with UNHASHABLE keys:
since hashable means immutable, then un-hashable means un-immutable which
simplifies (the two negatives cancel) to mutable. So unhashable is mutable. So

hashable    is immutable
unhashalble is mutable

Here is a quick breakdown of standard Python types

Hashable/immutable: strings, tuples, frozenset
mutable/unhashable: list, sets, dicts

The major difference between tuples and lists in Python is the former is
immutable and the later is not. So iff some other datatype (e.g., values in
sets, keys in dictionaries) needs to be hashable/immutable parts, use a tuple
not a list for it.

A frozenset can do everything that a set can do, but doesn't allow any mutator
methods to be called (so we cannot add a value to or remove a value from a
frozenset).

The constructor for a frozenset is frozenset(...) not {}. Note that once you've
constructed a frozen set you cannot change it (because it is immutable). If you
have a set s and need an equivalent frozenset, just write frozenset(s).

We will study hashing a bit later in the quarter: it is a technique for
allowing very efficient access to sets and dicts. ICS-46 (Data Structures)
studies hash tables in much more depth, in which you will implement the
equivalent of Python sets and dicts by using hash tables.

------------------------------------------------------------------------------

Comprehensions: list, tuple, set, dict

List, Tuple, Set Comprehensions:

Comprehensions are compact ways to generate complicated (but not too
complicated) lists, tuples, sets, and dicts. That is, they compactly solve some
problems but cannot solve all problems (for example, we cannot use them to
mutate data). The general form of a list comprehension is as follows, where
f means any function (or expression: we can also just write var because a name
by itself is a simple expression having a value) using var and p means any
predicate (or bool expresssion) using var.

[f(var) for var in iterable if p(var)]

Meaning: collect together into a list (because of the outer []) all of f(var)
values, for var taking on every value in iterable, but only collect the f(var)
value if p(var) is True.

For tuple or set comprehensions, we would use () and {} as the outermost
grouping symbol instead of [] (we'll talk about dicts at the end, which use
{} and : inside to get the job done and be distinguised from sets which use {}
without : inside).

Note that the "if p(var)" part is optional and we can also write comprehensions
as follows (in which case it has the same meaning as p(var) always being True).

[f(var) for var in iterable]   meaning   [f(var) for var in iterable if True]

for example

x = [i**2 for i in irange(1,10) if i%2==0]	# note: irange not range
print(x)

prints the squares of all the integers from 1 to 10 inclusive, but only if the
integer is even (leaves a remainder of 0 when divided by 2). Run it. Change it
a bit to get is to do something else. Here is another example

x = [2*c for c in 'some text' if c in 'bcdfghjklmnpqrstvwxy']
print(x)

which prints a list with strings that are doubled for all the consonants
(no aeiouy -or spaces for that matter): ['ss', 'mm', 'tt', 'xx', 'tt']

We can translate a list comprehension into equivalent code that uses more
familiar Python features.

x = []	       	  	   # start with an empty list
for var in iterable:	   # iterate through iterable
   if p(var):		   # if var is acceptable?
       x.append(f(var))	   # add f(var) next in the list

But often using a comprehension (in the right places: where you want to
generate some list, tuple, set or dict) is simpler. Not all lists that we
build can be written as simple comprehensions, but the ones that can are often
very simple to write, read, and understand when written as comprehensions.

What comprehensions aren't good for is putting information into a data structure
and then mutating/changing it during the comprehension; for that job you need
code more like the loop above. So when deciding whether or not to use a
comprehension, ask youself if you can specify each value in the data structure
without changing it (as was done above, using comprehensions).

Note that we can add-to (mutate) lists, sets, and dicts, but not tuples. For
tuples we would have to write this code with x = () at the top and
x = x + (var,) in the middle: which builds an entirely new tuple by catenating
the old one and a one-tuple (containing only x) and then binding x to the newly
constructed tuple. Don't worry about these details, but understand that unlike
lists, tuples have no mutator methods (so x.append(...) is not allowed)

Here is something interesting (using a set comprehension: notice {} around the
comprehension.

x = {c for c in "I've got plenty of nothing"}	# note ' in str delimited by "
print(sorted(x))

It prints a set of all the characters (in a list, in sorted order, created by
sorted(x)) in the string but because it is a set, each character occurs one
time. So even though a few c's have the same value, only one of each appears in
the set because of the semantics/meaning of sets. Note it prints

[' ', "'", 'I', 'e', 'f', 'g', 'h', 'i', 'l', 'n', 'o', 'p', 't', 'v', 'y']


If we used a list comprehension, it would be much longer because, for example,
the character 't' would occur 3 times in a list (but occurs only once in a set)


Dict Comprehensions:

The form for dict comprehensions is similar, here k and v are functions (or
expressions) using var. Notice the {} on the outside and the : on the inside,
separating the key from the value: that is how Python knows the comprehension
is a dict not a set.

{k(var) : v(var) for var in iterable if p(var)}

So

x = {k : len(k) for k in ['one', 'two', 'three', 'four', 'five']}
print(x)

prints a dictionary that stores keys that are these five words whose associated
values are the lengths of these words. Because dicts aren't ordered, it could
print as {'four': 4, 'three': 5, 'one': 3, 'five': 4, 'two': 3}

Finally, we can write a nested comprehensions, although they are harder to
understand than simple comprehensions.

x = {c for word in ['i', 'love', 'new', 'york'] for c in word if c not in 'aeiou'}
print(x)

It says to collect c's, by looking in each word w in the list, and looking at
each character c in each word: so the c collected at the beginning is the c
being iterated over in the second part of the comprehension (c in word...)

It prints a set of each different letter that is not a vowel, in each word
in the list. I could produce this same result by rewriting the outer part of the
comprehension as a loop, but leaving the inner one as a comprehension (union
merges two sets: does a bunch of adds).

x = set()
for word in ['i', 'love', 'new', 'york']:
    x = x.union( {c for c in word if c not in 'aeiou'} )
print(x)

or write it with no comprehensions at all

x = set()
for word in ['i', 'love', 'new', 'york']:
    for c in word:
        if c not in 'aeiou':
            x.add(c)
print(x)

So which of these is the most comprehendable: the pure comprehension, the
hybrid loop/comprehension, or the pure nested loops? What is important is that
we know how all three work, can write each correctly in any of these ways,
and then we can decide afterwords which way we want the code to appear. As we
program more, our preferences might change. I'd probably prefer the middle one.

Finally, here is a version of myprint (written above in the section above on the
binding of arguments and parameters) that uses a combination of the .join
function and a comprehension to create the string to print simply.

The .join function joins all the values in an interable into a string using the
prefix operator as a separator: '--'.join( ('My', 'dog', 'has', 'fleas') )
returns the string 'My--Dog--has--fleas'

def myprint(*args,sep=' ',end='\n'):
    s = sep.join(str(x) for x in args)+end       # create string to print
    print(s,end='')				 # print the string

WARNING: Once students learn about comprehensions, sometimes they go a bit
overboard as they learn about this feature. Here are some warning signs: When
writing a comprehension, you should (1) use the result produced in a later part
of the computation and (2) typically not mutate anything in the comprehension.
If the purpose of your computation is to mutate something, don't use a
comprehension.


Tuple Comprehensions are special:

The result of a tuple comprehension is special. You might expect it to produce
a tuple, but what it does is produce a special "generator" object that we can
iterate over. We will discuss generators in detail later in the quarter, so for
now we will examine just some simple examples. Given the code

x = (i for i in 'abc')
print(x)

You might expect this to print as ('a', 'b', 'c') but it prints as
<generator object <genexpr> at 0x02AAD710>

The result of a tuple comprehension is not a tuple: it is actually a generator.
The only thing that you need to know now about a generator is that you can
iterate over it, but ONLY ONCE. So, given the code

x = (i for i in 'abc')
for i in x:
    print(i)
for i in x:
    print(i)

it prints
a
b
c

Yes, it prints a, b, c and just prints it once: after the first loop finishes,
the generator is exhausted so the second loop produces 0 values.

Recall our discussion of changing any iterable into a list, tuple, set; so if
we wrote t  = tuple(x) or t = tuple( (i for i in 'abc') ), then
print(t) would print ('a', 'b', 'c'). In fact, we could even write
t = tuple(i for i in 'abc') because by default, comprehensions are tuple
comprehensions.

Of course, we could also write things like 
l = list(i for i in 'abc')
s = set (i for i in 'abc')

but these are equivalent to writing the standard comprehensions more simply:
l = [i for i in 'abc']
s = {i for i in 'abc'}

------------------------------------------------------------------------------

The zip function (and enumerate too)

Zip:

There is a very interesting function called zip that takes an arbitrary number
of iterable arguments and zips/interleaves them together (like a zipper does
for the teeth on each side). Let's start by looking at just the two argument
version of zip.

What zip actually produces is a generator -the ability to get the results of
zipping- not the result itself. See the discussion above about how tuple
comprehensions produce generators.

So to "get the result itself" we should use a for loop or constructor (as shown
in most of the examples below) to iterate over the result of calling zip.
The following code

z = zip( ('a','b','c'), (1, 2, 3) )  # I used two tuples for iterator arguments
print('z:',z,'list of z:',list(z))

prints

z: <zip object at 0x02A4D990> list of z: [('a', 1), ('b', 2), ('c', 3)]

Here, z refers to a zip generator object; the result of using z in the list
constructor is [('a', 1), ('b', 2), ('c', 3)] which zips/interleaves the values
from the first iterable and the values from the second:
[(first from first,first from second),(second from first,second from second),  
 (third from first,third from second)]

What happens when the iterables are of different lengths? Try it

z = zip( ['a','b','c'], (1, 2) )  # I used a list and a tuple for iterables
print(list(z))		       	  # prints [('a', 1), ('b', 2)]

So when one iterable runs out, the process stops. Here is a more complex
example with three iterable parameters of different sizes. Can you predict
the results: do so, and only then run the code.

z = zip( ['a','b','c','d','e'], (1, 2, 3), ['1st', '2nd', '3rd', '4th'] )
print(list(z))

Of course, this generalizes for any number of arguments, interleaving them all
(from first to last) until any iterable runs out. So the number of values in
the result is the minimum of the number of values of the argument iterables.

Note one way zip is very useful: suppose we want to iterate over values in
two lists simultaneously, l1 and l2, operating on the first pair of values in
each, the second pair of values in each, etc. We can use zip to do this by
writing:

for i,j in zip(l1,l2):
    process i and j: the next pair of values in each

So

for i,j in zip ( ('a','b','c'), (1,2,3) ):
    print(i,j)

prints

a 1
b 2
c 3


Enumerate:

Finally, this is a convenient time to toss in another quick example: enumerate.
It also also produces a generator as a result, but has just one iterable
argument, and an optional 2nd argument that is a number. It returns tuples
whose first values are numbers (starting at the value of the second parameter;
leave it out and unsurprisingly, they start as 0) and whose second values are
the values in the iterable. So, if we write

e = enumerate(['a','b','c','d'], 5)
print(list(e))

it prints [(5, 'a'), (6, 'b'), (7, 'c'), (8, 'd')]

Given l = ['a','b','c','d','e'] we could use enumerate to write the following
code more simply

for i in range(len(l)):
    print(i+1,l[i])

(which prints 1 a, 2 b, 3 c, 4 d, 5 e) by writing

for i,x in enumerate(l,1)
     print(i,x)

Another nice example of enumerate is when reading a file a line at a time.
Assume file refers to an open file. Instead of writing

line_number = 1
for line in file:
    .... process line_number and line
    line_number += 1

We can write just

for line_number, line in enumerate(file,1):
    .... process line_number and line

You might ask now, why do these things (tuple comprehension, zip, enumerate)
produce generators and not just tuples or lists? That is an excellent question.
It goes right along with the excellent question why does sorted(...) produce a
list and not an iterable? We will discuss these issues later in the quarter.
It mostly has to do with space efficiency.

------------------------------------------------------------------------------

**kargs for dictionary of not matched named arguments in function calls

Recall the use of *args in a function parameter list. We can also write the
symbol **kargs (we can write ** and any word, but kargs or kwargs are the
standard ones). If we use it to specify a parameter, it must occur as the last
parameter. kargs stands for keyword arguments. Basically, if Python has any 
keywords arguments that do not match keyword parameters (see the large
discussion of argument/paramteter binding above, which includes *args but
doesn't include **kargs) they are all put in a dictionary that is stored in the
last parameter named kargs.

So, imagine we define the following function

def f(a,b,**kargs):
  print(a,b,kargs)

and call it by

f(c=3,a=1,b=2,d=4)

it prints: 1 2 {'c': 3, 'd': 4}

Here Python found two named arguments (c=3 and d=4) whose names did not appear
in the function header of f (which specifies only a and b, and of course the
special **kargs), so while Python bound a to 1 and b to 2 (the parameter names
specified in the function header, matched to similarly named arguments) it
created a dictionary with all the other named arguments: {'c': 3, 'd': 4} and
bound kargs to that dict. The same result would be printed for the call

f(1,2,d=4,c=3)

We will use **kargs to understand a special use of of dict constructors (below).
We will also use **kargs (and learn something new in the process) when
discussing how to (1) call methods in decorators and (2) call overridden
methods using inheritance much later in the quarter.

Note that to write a perfectly general function with parameters, we

def f(*args,**kargs):
  print(args,kargs)

Now, any legal call of f (one with any legal combination of positional and
named arguments) will populate the *args and **kargs structures appropriately.

Calling

f(1,2,c=3,d=4)     prints (1, 2) {'c': 3, 'd': 4}
f(a=1,b=2,c=3,d=4) prints () {'c': 3, 'b': 2, 'a': 1, 'd': 4}

If we define

def g(a,b,c,d):
    print(a,b,c,d)

def f(*args,**kargs):
  g(*args,**kargs)

the arguments *args and **kargs in the call of g expand the args tuple to
be positional arguments and the **kargs dictionary to be named arguments

Calling

f(1,2,c=3,d=4)     prints 1 2 3 4: it calls g(1,2,c=3,d=4)
f(a=1,b=2,c=3,d=4) prints 1 2 3 4: it calls g(c=3,b=2,a=1,d=4)

1) Writing * and ** when specifying parameters makes those parameter names a
   tuple/dict respectively

2) Using the parameter names by themselves in the function is equivalent to 
    using the tuple/dict respectively

3) Using * and ** followed by the parameter name as arguments to function
   calls expands all the values in the tuple/dict respectively to represent
   different arguments.

Experiment with *args/**kargs as parameters of functions and args/kargs and
*args/**kargs as arguments to other function calls.

------------------------------------------------------------------------------

Lists, Tuples, Sets, Dictionaries (frozenset and defaultdict)

You need to have pretty good grasp of these important data types, meaning how to
construct them and the commong methods/operations we can call on them. Really
you should get familiar with reading the online documentation for all these
data types (see the Python Library Reference link on the homepage for the
course).

4. 6: Sequence Types includes Lists (mutable) and Tuples (immutable)
4. 9: Set Types includes set (mutable) and frozenset (immutable)
4.10: Mapping Types includes dict and defaultdict (both mutable)

-----

4.6: Sequence Types includes Lists (mutable) and Tuples (immutable)
These sequence operations (operators and functions) are defined in 4.6.1
   x in s, x not in s, s + t, s * n, s[i], s[i:j], s[i:j:k], len(s), min(s), 
   max(s), s.index(x[, i[, j]]), s.count(x)

Mutable sequence allow the following operations, defined in 4.6.3
  s[i] = x , s[i:j] = t, del s[i:j], s[i:j:k] = t,, del s[i:j:k], s.append(x)
  s.clear(), s.copy(),s.extend(t), s.insert(i, x), s.pop(), s.pop(i),
  s.remove(x), s.reverse()

  It also discusses list/tuple constructors and sort for list.

  note that the append method is especially important for building up sequences
  like lists. Also to return and remove a value from a sequence, we call
    x = s.pop(i)
  is equivalent to 
    x = s[i]
    del s[i]
  and calling s.pop() uses the value 0 (the first index in the sequence)

-----

4. 9: Set Types includes set (mutable) and frozenset (immutable)
These set (operators and functions) are defined in 4.6.1.9
  len(s), x in s, x not in s, isdisjoint(other), issubset(other), set <= other, 
  set < other, issuperset(other), set >= other, set > other, union(other, ...),
  intersection(other, ...), difference(other, ...), symmetric_difference(other),
  copy; also the operators | (for union), & (for intersection), - (for
  difference), and ^ (for symmetic difference)

Sets, which are mutable, allow the following operations
  update(other, ...), intersection_update(other, ...),
  difference_update(other, ...), symmetric_difference_update(other), add(elem),
  remove(elem), discard(elem), pop(), clear(); also the operators |= (union
  update), &= (intersection update), -= (difference update), ^= (symmetric
  difference update)

-----

4.10: Mapping Types includes dict and defaultdict (both mutable)
These dict (operators and functions) are defined in 4.10
  d[key] = value , del d[key], key in d, key not in d, iter(d), clear(), copy(),
  fromkeys(seq[, value]), get(key[, default]), items(), keys(),
  pop(key[, default]), popitem(), setdefault(key[, default]), update([other]),
  values() 

Important Notes on dicts:
  d[k] accesses the value associated with a key
       (raising an exception if k not in d)

  d.get(k,default) returns d[k] if k in d; returns default if k not in d

  d.setdefault(k,default) returns d[k] if k in d; if k not in d it
    (a) sets d[k] = default
    (b) returns d[k]
  writing d.setdefault(k,default) is equivalent to (but more efficient than)
  writing
      if k in d:
          return d[k]
      else
          d[k] = default
          return d[k]

There is a type called defaultdict (see 8.3.4) whose constructor generally
takes an argument that is a reference to any object that can be called with no
arguments. Very frequently we use name of a class that when called will
construct a new value: if the argument is int, it will call int() producing the
value 0; if the argument is list, it will call list() producing an empty list;
if the argument is set, it will call set() producing an empty set; etc.

Wenever a key is accessed for the first time (i.e., that key is accessed but
not already associated with a value in the dictionary) in a defaultdictionary,
it will associate that key with the value created by calling the reference to
the object supplied to the constructor.

Here is an example of defaultdict in action. Often it simplifies our use of
dictionaries.


from collections import defaultdict # in same module as namedtuple
letters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']
freq_map = defaultdict(int)    # int not int(); but int() returns 0 when called
for l in letters:
    freq_map[l] += 1	       # in dict, exception raised if l not in d, but
print(freq_map)                # defaultdict calls int() putting 0 there first

We could use a dict, but we would have to rewrite the code as follows (which is
a bit less efficient too); defaultdict does the same thing, but automatically.

letters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']
freq_dict = dict()	       # note dict only
for l in letters:
    if l not in freq_dict:     # must check l in freq_dict before freq_dict[l]
        freq_dict[l] = int()   # int() constructor returns 0; could write 0 here
    freq_dict[l] += 1	       # l is guaranteed in freq_dict, either because
print(freq_dict)	   	       #  it was there originally, or put there

Another way to do the same thing (but also a bit less efficient) uses the
setdefault method (listed above)

letters = ['a', 'x', 'b', 'x', 'f', 'a', 'x']
freq_dict = dict()	       # note dict only
for l in letters:
    freq_dict[l] = freq_dict.setdefault(l,0) + 1
print(freq_dict)	   	       

Here we evaluate the right side of the = first; if l is already in the map,
its associated value is returned; if not, l is put in the map with an associated
value of 0, then this assocated value is returned (and incremented, and stored
back into freq_dict[l] replacing the 0 just put there).

You should achieve a good understanding of why each of these three scripts work
and why they alll produce equivalent results.

Often we use defaultdicts with list instead of int: just as int() produces the
object 0 associated with a new key, list() creates an empty list associated
with a new key (and later we add things to that list); likewise we can use
defaultdicts with set to get an empty set with a new key.

So, if we wrote x = defaultdict(list) and then wrote x['bob'].append(1) then
x['bob'] is associated with [1] (the empty list with 1 appended). If we then
wrote x['bob'].append(2), then x['bob'] is associated with [1, 2].

Just as with comprehensions, what is important is that we know how things like
defaultdicts and dicts (with the setdefault method) work, so that we can
correctly write code in any of these ways. We can decide afterwords which way
we want the code to appear. As we program more, our preferences might change.
I have found defaultdicts are mostly what I to use to simplify my code, byut
every so often I must use a regular dict.

Later in the quarter we will use inheritance to show how to write the
defaultdict class simply, by extending the dict class.

------------------------------------------------------------------------------

Exceptions: example from prompt_for_int

We do two things with exceptions in Python: we raise them (with the raise
statement) and we handle them (with the try/except statement). Exceptions were
not in early programming languages, but were introduced big time in the Ada
language in the early 1980s, and have been parts of most new languages since
then.

A function raises an exception if it cannot do the job it is being asked to
do. Rather than fail silently, possibly producing a bogus answer that gets used
to compute a bogus result, it is better that the computation declares a problem
and if no one can recover from it (see handling exceptions below) the
computation halts with an error message to the user.

For example, if your program has a list l and you write l[5] but l has nothing
stored in this position, Python raises the IndexError exception. If you haven't
planned for this possibility, and told Python to handle the exception and how
to continue the calculation, then the program just terminates and Python prints:

IndexError: list index out of range

Why doesn't it print the index value 5 and the lenth of list l?. I don't know.
That certainly seems like important and useful information, and Python knows
those two values. I try to make my exception messages include useful
information.

There are lots of ways to handle exceptions. Here is a drastically simplified
example from my prompt class (this isn't the real code, but a simplification
for looking at a good use of exception handling). But it does a good job of
introducing the try/except control form which tries to execute a block of code
and handles any exceptions it raises.

If we write a try/except and specify the name of no exception, it will handle
any exception. The name Exception is the name of the most generic exception.

We can write a try/except statement many excepts, each one specifying a 
specific exception to handle, and what to do when that exception is raised. In
fact, int('x') raises the ValueError exception, so I use ValueError in the
except clause below.

def prompt_for_int(prompt_text):
    while True:
        try:
            response = input(prompt_text+': ')    # response is used in except
            answer = int(response)
            return answer
        except ValueError:
            print('  You bozo, you entered "',response,'"',sep='')
	    print('  That is not a legal int')

print(prompt_for_int('Enter a positive number'))

So, this is an "infinite" while loop, but there is a return statement at the
bottom of the try-block; if it gets executed, it returns from the function,
thus terminating the loop. The loop body is a try/except; the body of the
try/except

1) prompts the user (this cannot fail)
2) calls int(response) on the user's input (which can raise the ValueError
   exception, if the user types characters that cannot be interpreted as an
   integer)
3) if that exception is not raised, the return statement returns an int object
   representing the integer the user typed

But if the exception is raised, it is handled by the except clause, which
prints some information. Now the try/except is finished, but it is in an
infinite loop, so it goes around the loop again, reprompting the user (over and
over until the user enters a legal int).

Actually, the body of try could be simplified (with the same behavior) to just

  response = input(prompt_text+': ')    # response is used in except
  return int(answer)

If an exception is raised while the return statement is evaluating the int
function, it still gets handled in except. We CANNOT write it in one line
because the name response is used in the except clause (in the first print).
If this WASN'T the case, we could write just

  return int(input(prompt_text+': '))    # if response not used in except

For example, we might just say 'Illegal input' in the except.

Finally, in Java we throw and catch exceptions (obvious opposites) so I might 
sometimes use the wrong term. That is becuase I think more generally about
programming than "in a language", and translate what I'm thinking to the
terminology of the language I am using, but sometime I get it wrong.

------------------------------------------------------------------------------

Name spaces (for objects): __dict__

Every object has a special variable named __dict__ that stores all its
namespace bindings in a dictionary. During this quarter we will systematically
study class names that start and end with two underscores. Writing x.a = 1
is similar to writing x.__dict__['x'] = 1; both associate a name with a value
in the object. We will explore the uses of this kind of knowledge in much more
depth later in the quarter.

Here is a brief illustration of the point above. Note that there is a small
Python script that illustrates the point. This is often the case.

class C:
    def __init__(self): pass

o = C()
o.a = 1
print(o.a)           # prints 1

o.__dict__['a'] = 2
print(o.a)           # prints 2

o.__dict__['b'] = 3
print(o.a,o.b)       # prints 2 3

------------------------------------------------------------------------------

Trivial Things.

An empty dict is created by {} and empty set by set() (we can't use {} for an
empty set because Python would think it is a dict). Any non-empty dicts can
be distinguished from a non-empy set because a non-empty dict will always have
the : character inside {} separating keys from values.

A one value tuple must be written like (1,) with that "funny" comma (we can't
write just (1) because that is just the value 1, not a tuple storing just 1).

------------------------------------------------------------------------------

Questions:

1. Describe, in term of binding, what happens if the first statement in a
module is x = 0, in terms of the module object and its namespace.

2. Assume that we have executed the statement x = 1. Describe, in terms of
binding, what is the semantics of the statement x += 1.

3. What is printed in print(f(0)) if we define f as follows?

  def f(x):
      pass

4. Using the kind of pictures dicussed inthe Binding section above, illustrate
the meaning of a module named m that contains the following statements:

  x = 1
  y = 2
  z = y

And a module named script that contains the following statements:

  import m
  a = m.x
  m.y = 10
  from m import y
  from m import z as b
  z = y
  del m.z
  c = 10

The result will be two large rounded-rectangles (objects for modules m and 
script) which contain labeled boxes that refer to other rounded-rectangles
(objects for int values), some of which are shared (referred to by multiple
names)

5. Predict what the following script will produce and explain why.

print(print(5))
print=1
print(print)

6a. Write a simple function named count that returns the number of times a value
is in a list; write the a simple function named indexes that returns a list of
indexes in a list that a value returns. Use the appropriate kind of for loop.
For example, count(5, [5,3,4,5,1,2,5]) returns 3; indexes(5, [5,3,4,5,1,2,5])
returns [0,3,6].

7. Suppose that we define the functions double, triple, and magnitude (as done
above). Write the function call, such that call('double',5) returns the result
double(5); call('triple',5) returns the result triple(5); call('magnitude',5)
returns the result magnitude(5). Hint: use eval.

8. Write a function named between that is defined with two parameters. It
returns a reference to a function that has one parameter, which returns whether
or not its one parameter is between (inclusive) the two arguments supplied when
between is called. For example

college_age = between(18,22)
print( college_age(20) )

print True because 18 <= 20 <= 22.

9. Assume s = 'Fortunate'. Explain how Python evalues s.replace('t','c'). Sure,
the result it produces is 'Forcunace', but exactly how does Python know which
function to call and how to call that function with these arguments. Hint: Use
the Fundamenal Equation of Object-Oriented Programming.

9.5 This is tricky: it requires a good understanding of exec, eval, and what
characters really appear in strings when you type them on the console.
(1) prompt the user to enter a string that defines a function (using \n where
new lines would be in the function); (2) use exec to define the function;
(3) prompt the user to enter a call to the function and print what it evaluates
to. The interaction might look like:

Enter function definition as string: def f(n):\n    returns 2*n
Enter function call as string      : f(3)
6

Hint: when you enter \n in a string, what characters are entered? Use the
replace function to "fix" them to exec will work.

10. Assume that you have a list of tuples, where each tuple is a name and
birthday: e.g., ('alex', (9, 4, 1988)) and ('mark', (11, 29, 1990)). The
birthday 3-tuple, consists of a month, followed by day, followed by year. Write
a for-loop using sorted and a lambda to print out the tuples in the list in
order of their bithdays (just months and days) so the 'alex' tuple prints
before the 'mark' tuple because September 4th comes before November 29th; all
people who have the same birthday should be printed in alphabetical order.
Hint write a lambda that uses a key that is a person's month value, followed by
a day value, followed by a name value.

11. What does the following script print?

print('a','b','c',sep=x)
print('d','e','f',sep='')
print('g','j','i',sep=':',end=:)
print('j','k','l',sep='--',end='?')
print('m',end='\n\n')
print('n')

12. Assume s is a string. What is the value of s[-1:0:-1]? Assume l is a list.
Write the simplest loop that prints all values in a list except the first and
last (if the list has2 or fewer values, it should print nothing).

13. Write a single Python statement using a conditional expression that is
equivalent to the following two statementso

t= 0
if x < 0:
    t = -1

14. What can we say about
  len of set(d.keys())   compared to len of d.keys?
  len of set(d.values()) compared to len of d.values()?
  len of set(d.items())  compared to len of d.items()?

15. Assume we import the copy function from the copy module. What is the
difference between the result produced by list((1,2,3)) and copy((1,2,3))?

15.5 Using the kind of pictures dicussed inthe Binding section above, illustrate
the meaning of the following and determine what is printed.

  x = [ [0], [1]]
  y = list(x)
  x[0][0] = 'a'
  print(x,y)

16a. Assume we have a list of students (ls) and a list of their gpas (lg).
Create a dictionary whose first key is the first student in ls and whose
associated value is the first gpa in the lg; whose second key is the second
student in ls and whose associated value is the second gpa in the lg; etc.
So if ls = ['bob','carol','ted','alice'] and lg = [3.0, 3.2, 2,8, 3.6] the
resulting dict might print as {'carol': 3.2, 'ted': 2, 'alice': 8, 'bob': 3.0}.
Hint: use the dict constructor and the zip function.

16b. Assume that we have a list of runners in the order they finished the race.
For example ['bob','carol','ted','alice']. Create a dictionary whose keys are
the students and whose values are the place in which they finished. For this
example the resulting dict might print as 
{'carol': 2, 'ted': 3, 'alice': 4, 'bob': 1}. Hint: use a comprehension and
enumerate.

17. The following script uses many topics that are covered in the lecture.

Write a script that reads a multiline file of words separated by spaces
(no punctuation) and builds a dictionary whose keys are the words and whose
values are lists of the line numbers that the words are on (with no duplicate
line numbers in each list). Print all the words (in sorted order, one per line)
with the list of their line numbers afterwards. For example, the 3 line file

to be or
not to be
that is the question

would print as

be [1, 2]
is [3]
not [2]
or [1]
question [3]
that [3]
the [3]
to [1, 2]

My solution was 8 lines long (including one import). It used a defaultdict,
three loops, three function calls (open, enumerate, and sorted), and four
method calls (rstrip, split, append).
