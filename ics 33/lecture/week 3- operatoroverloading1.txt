			Operator Overloading I


Now that we have reviewed the fundamentals of classes, we are going to cover
some new material about them: how we can write certain class methods that are
used by Python in a special way: we don't call these methods directly, but
Python does. All these special methods have their names writen between double
underscores (just like __init__ which is also one of these special methods).

Most of these methods (but not all) are invoked by Python operators (whose
arguments are instances of the class that they are defined in) so we call this
technique "operator overloading": that means overloading (giving more than one
meaning) to the semantics the standard operators for objects constructed from
user classes (which really is a form of polymorphism). Overloading has a good,
not bad connotation here. By studying operator overloading, we will better
understand how Python executes our programs, and be able to write classes that
are more powerful, by exploiting our understanding of this mechanism.

Note that this material is also covered in Lutz, "Learning Python", in
Chapter 29. While learning this material, we illustrate each overloaded
operator simply with methods defined in a "simple" class, C. Later we will apply
this technique to a bigger example; but, a typical class has only some of
its operators overloaded: not all operators are meaningful for every class.

------------------------------------------------------------------------------

__init__

We'll start with __init__ because you have probably already written many of
these methods. Recall that when you "call the class" (write the class name
followed by parentheses), you can supply it with some arguments. Python creates
an object (something that has a namespace/__dict__) for the instance of the
class and then calls __init__ with a reference to the object it created and all
the arguments in the "call of the class".  So calling C(a,b,c) leads Python to
call C.__init__(self,a,b,c) where self refers to the object it just created.
Here is the beginning of this class, whose argument is a list of strings

class C:
    def __init__(self,los):
        self.los = los

Note that self.los = ... establishes a new name in the namespace of the
constructed object and initializes it to ...
        
Like the methods that we will discuss below, we don't call __init__ but Python
does, automatically whenwe "call the class" to construct a new object. Note too
that it is perfectly OK to call C. __init__(...) explcitly on some object to
reinitialize it.

------------------------------------------------------------------------------

__len__

We can call the len function on any object. It translates into a call of the
parameterless __len__ method on the object. len is defined, and automatically
imported from the builtins module, as

def len(x):
    return x.__len__()

Note that some objects (e.g., those of class/type int) do not define a __len__
method. If we call len(1) Python reports: TypeError: object of type 'int' has
no len()

The following class illustrates this method. This class is initialized with a
list of strings. The len method returns not the length of the list, but the
sum of the length of all the strings in list. Because we can write the __len__
method in class C, we can determine what the meaning of len is for objects from
class C.

class C:
    def __init__(self,los):
        self.los = los
        
    def __len__(self):
        print('Calling len')
        return sum((len(i) for i in self.los))

x = C(['ab','cd'])
print(len(x))

This script prints 'Calling len' and then 4 (because 'ab' has 2 characters and
'cd' has 2 more). The __len__ method calls sum to add up the values in a tuple
that is created by a comprehension of calling len on every value is self.los.

------------------------------------------------------------------------------

__bool__

Whenever Python needs to interpret some object as a boolean value, it calls the
parameterless method __bool__ on the object. For example, if we write an "if"
or "while" statement whose boolean test is just an object, Python attempts to
call the __bool__function on that object to determine whether its boolean
equivalent represents True or False.

For the following class (no __len__ is defined: we will see for a minute why
this is important soon) and script, the if statement would raise an exception.

class C:
    def __init__(self,los):
        self.los = los
        
x = C(['ab','cd'])
if x:
    pass

Strangely enough, the exception it raises is:

  TypeError: object of type 'C' has no len()

The actual rule in Python for evaluating an object as if it were a boolean
value is to first try to call __bool__ on the object (which cannot be done
above) and return its result; if that method is not present, Python instread
returns whether its len is != 0. If there is no __len__ function Python runs
out of options and raises the exception show above.

So, if described C as we did in the previous section, writing

  if x :
      pass

is equivalent to calling

  if len(x) != 0:
     pass

which evaluates to True for this binding to x (whose len, recall, is 4)

But if we defined C as follows, an object constructed from class C returns False
only if the catenation of all the strings in los is 'False'.

class C:
    def __init__(self,los):
        self.los = los
        
    def __len__(self):
        print('Calling len')
        return sum((len(i) for i in self.los))
    
    def __bool__(self):
        return ''.join(self.los) != 'False'
  
So the boolean value for C(['ab','cd']) would return True, and so would C([]).
But C(['Fa','l','se']) would return False: all return their values because
Python uses the __bool__ function supplied above, and doesn't have to (nor does
it) call len to compute an answer.

By the way, this also explains why we can test list, tuple, set, and dict 
objects as booleans: if any is empty (len = 0) it represents False, if any is
not empty, it represents True. Also, the object None has a boolean value of
False (the NoneType class specifies a __bool__ method that always return False).

--------------------

Interlude: Short-Circuit Logical Operators: and their real meanings

The operators and/or are called short-ciruit operators, because unlike other
operators (which evaluate both of their operands before being applied), short-
circuit operators evaluate their left operand first, and sometimes don't need
to evaluate their right operand: True or ... is True and False and ... is
False. So if the or operator's left operand is True, it doesn't need to evalate
its right operand: the result is always True; and if the and operator's left
operand is False, it doesn't need to evalate its right operand: the result is
always False. This rule saves time, but it is more important for another
reason (discussed below).

If the left operands of and/or is True/False it must evaluate the right operand
in order to compute its result.

So, for example, if we wrote the following if/test (assume d is a dict)

  if k in d.keys() and d[k] == 0:
      ....

Python would first evaluate the expression: k in d.keys(). When False it would
determine the value of the and operator is already known, and is False. It
would not have to evaluate d[k] == 0, which is a good thing, because evaluating
d[k] would throw a KeyError exception, because k is not a key in d. 

So, while short-circuit operators can save a little time, that is not their
most important purpose; avoiding raising exceptions is the primary reason that
and/or operators are short-circuit.

Even without short-circuit operators, we could write this same expression as

  if k in d.keys():
      if d[k] == 0:
          ....

But that requires a nested if statement and is much more cumbersome. It is
better to spend some time learning about short-circuit operators now, and then
be able to use them appropriately later, to write simpler code.

Finally, the exact meaning of and/or is a bit more subtle, and concerns the
boolean interpretation of values (i.e., the__bool__ method). Let's look at and
first. If the boolean interpretation (computed by __bool__) of the left operand
of and is as False, we know that we don't have to evaluate the right operand.
We said that the result is False, but realy the result is the actual value of
left operand, not its boolean interpretation. So [] and anything evaluates to
[] (a value whose boolean interpretation is False).

Likewise if the boolean interpretation (computed by __bool__) of the left
operand of or is True, we know that we don't have to evaluate the right operand.
We said that the result is True, but realy the result is the actual value of
left operand, not its boolean interpretation. So [1] or anything evaluates to
[1] (a value whose boolean value is True).

Similarly, if the boolean interpretation of the left operand of or is False, we
need to evaluate the right operand to compute the result of or, and the result
will just be the value of the right operand (not its boolean interpretation):
so (any value considered False) or [] is [], and (any value considered False)
or [1] is [1].

Likewise, if the boolean interpretation of the left operand of and is True, we
need to evaluate the right operand to compute the result of and, and the result
will just be the value of the right operand (not its boolean interpretation):
so (any value considered True) and [] is [], and (any value considered True)
and [1] is [1].

Most programmers use logical operators where boolean values are needed (like in
"if" and "while" loops), so regardless of their strange results, we are
interested only in the boolean interpretation of the result (which correponds
to our intution about and/or). But the reality in Python is a bit subtler, and
sometimes programmers do rely on understanding the exact meaning of the and/or
operators.

Note that not has only one operand, so there is no way to short-circuit it.
Also, note that not always returns a bool value (unlike what we learned above).
That is, not [] evaluates to  True; not [1] evalutes to False.

------------------------------------------------------------------------------

Relational operators: 
__lt__ (__gt__, __le__, __ge__, __eq__, __ne__): < (>, <=, >=, ==, and !=)

In this section, the overloaded operators that we discuss are really operators,
and we overload their meaning to compute values on new classes/types. Python
translates any occurance of a relational operator into a call on the approprate
method for its left operand: x < y is translated to x.__lt__(y) which by the
Fundamental Equation of Object Oriented Programming is type(x).__lt__(x,y) or,
assuming C is a class and x is of type C, C.__lt__(x,y). Please note that int
is just a class in Python, so it translate 12 < x into type(12).__lt__(12,x)
which is equivalent to int.__lt__(12,x). That is really what is happening in
Python: using < with an integer first argument calls the method __lt__ defined
in the class the object 12 is constructed from (which is int).

--------------------
Comparing objects from the same class:

We will start our discussion by defining these relational operators to work
when comparing two objects from class C. Later we will discuss how to expand
them to compare against other types (here, just int).

Back to C, first using the definition of C above, if we wrote

x = C(['1','5'])
y = C(['5','1'])
print(x < y)

Python raises the exception: TypeError: unorderable types: C() < C()

Likewise, it raises the same exception for

print(x < 10)

Python raises the exception: TypeError: unorderable types: C() < int


, indicating
that C defines no method __lt__. Of course, Python first translates 


Note that the cause of the problem is that class C defines no __lt__ method.
Python translate x < ... into type(x).__lt__(x,...) which is equivalent here to
C.__lt__(x,...). But there is not __lt__ method defined in class C.

So, there is no built-in meaning for comparing an object of class/type C with
any object of any other type. There is no C.__lt__ method. But, by defining an
__lt__ method in C, there is a method for Python to call when it needs to
compute the < operator on two operands, whose left is an instance of class C.

So to start, let's add the following definition to the C class

    def __lt__(self,right):
        return self.los < right.los

Notice the < operator in __lt__ is not recursive! Python calls the __lt__
method above when comparing two objects constructed from class C; but inside
this method the < operator is called on two lists, so it calls the __lt__
method defined in the list class list.__lt__(self.los,right.los) to compute the
results: an __lt__ in a different class.

The __lt__ method above would be recursive if its body were return self < right
(causing inifinite recursion, a topic that we will cover in depth later).

So, to compare two C values, we will use the standard < to compare the self.los
instance variable (we discussed how list of strings are compared in Week #1).
So now, when evaluating x < y in the example below, the method call C.__lt__ is
found and it is called with arguemtns (x,y): as C.__lt__(x,y).

x = C(['1','5'])
y = C(['5','1'])
print(x < y)

Python prints: True

What if we changed the print to print(x > y) and executed the code? Would Python
throw an exception because there is no __gt__ method defined in class C?

It turns out Python is able to compute the correct answer. Python's rule for
evaluating > is a bit more complicated. It first tries to call C.__gt__(x,y)
but an exception is raised because __gt__ is not defined in C. Mathematically,
x > y is true exactly when y < x is true: so, we can use the __lt__ method to
compute the __gt__ method if we reverse the operands: C.__gt__(x,y) is the same
as C.__lt__(y,x). So Python tries to evaluate y < x, which means C.__lt__(y,x)
which successfully computes its answer.

So, we can let Python implicitly call __lt__ with the operands reversed, as
above, or we can explicitly implement __gt__ either directly (as we did for
__lt__) or we can implement __gt__ by having it explicitly call __lt__ with the
arguments reversed. Either

    def __gt__(self,right):
        return self.los > right.los

    def __gt__(self,right):
        return right < self # or right.__lt__(self) or C.__lt__(right,self)

So there are a variety of implicit and explicit ways in which we can use the
__gt__ method to compute the correct result. Finally, note that we can get the
same behavior by defining only __gt__ which Python will call with reversed
operands if it needs to compute the __lt__ if that method is undefined.

Python can use __lt__ to compute __gt__ and __gt__ to compute __lt__ as needed.
So, writing one of these pairs allows Python to compute both relations.

What if we changed the print to print(x <= y) and executed the code?

Python again raises the exception: TypeError: unorderable types: C() <= C()

In fact, the __le__ and __ge__ pair of methods are opposites like __lt__ and
__gt__. If we define the __le__ method, and Python needs to compute x >= y, it
will try the call to C.__le__(y,x), because x >= y is true exactly when y <= x
is true. And if we define the __ge__ method and Python needs to computer x <= y
it will translate the call to C.__ge__(y,x), because x <= y when y >= x.

Finally, if we don't define an __eq__ method, Python substitutes the is
operator; if we don't define a __ne__ method Python call __eq__ and negates
the result. So unlike the other pairs, in this pair, an undefined  __ne__ method
calls __eq__ but an undefined __eq__ will not call __ne__. For example, with
neither __eq__ nor __ne__ defined

x=C(['1'])
y=C(['1'])
z=x

print(x == y, x is y, x == z, x is z)
print(x != y, x is not y, x != z, x is not z)

Prints

  False False True True
  True True False False

Here ==/is and !=/not is produce the same results.

----
is vs. == interlude

Recall that the "is"  operator is called the object-identity operator. It
evaluates to True when its left operand reference refers to the SAME OBJECT as
its right operand reference. In the pictures that we have been drawing, this
means the left/right references (arrows) refer to the same object.

The == operator (when present) compares objects by their state. It is possible
that two different objects (objects for which "is" evaluates to False) store
the same state, so for them == should evaluate to True. This is the case for
the objects x and y shown above: they refer to different objects, but each of
the objects referred to has the same state: the self.los reference of each
refers to a list containing one string: '1'.
----

So, if we define the __eq__ method as follows (True when the lists are same
regardless of identity)

    def __eq__(self,right):
        return self.los == right.los

print(x == y, x is y, x == z, x is z)
print(x != y, x is not y, x != z, x is not z)

now prints

  True False True True
  False True False False

So in summary, to get all six relational operators to work correctly for
comparing two objects of the same class, we can define all six or chose one of
__lt__/__gt__, one of __le__/__ge__, and always __eq__ to define, and Python
will call one of these to compute the correct value for any of the undefined
relational operators.

Note that although Python doesn't do it, we can implement all the relational
operators using only < (or > or <= or >= we show only < below): although this
approach might not be efficient in execution, the last 5 methods would be the
same in every  class, all depending on the meaning of __lt__. In fact, here is
the equivalence (each proven by the law of trichotomy: x < y, x == y, or x > y)

Relation |  < only + logical operators
---------+------------------------------
 x <  y  |      x <  y
 x >  y	 |      y <  x
 x <= y	 | not (y < x)
 x >= y	 | not (x < y)
 x == y	 | not (x < y or y < x)
 x != y	 |      x < y or y < x,  or we could write not(x == y), using ==

So, we could write each of these operators as illustrated above and be able to
compare values from the C class in all possible ways. We will later see how to
use a mix-in via class inheritence to simplify this process. You can also look
in the functools module in Python's library for the total_ordering decorator,
which supplies the other operators so long as the class defines one of
__lt__, __le__, __gt__, or __ge__ and also supplies the __eq__ method.

--------------------
Comparing objects from different classes:

Now we will discuss what we must do if we also want Python to be able to compare
objects of different types: here type C with objects of another type; for
simplicity we will use the standard int type as the other one for comparison,
but our approach generalizes to all other types as well. Again, assume x refers
to an object constructed from class C.

Writing the code print(x < 15) won't magically work. As you would suspect,
this will not end well, because Python raises the exception: AttributeError:
'int' object has no attribute 'los' (in the body of the __lt__ method). The
current definition assumes type(right) is C, but here it is an int. Now, maybe
it makes NO sense to do such a comparison, so raising this exception is as good
as any other; or, mabye we should test whether type(right) is C and raise a
different exception with a better message. The accepted exception to raise is
TypeError, which with the correct string would produce the same result as if
the method were not defined (see below).

But if it makes sense to compare a C and an int, we can write more code to fix
the "problem", expressing how to compare Cs to integers. Suppose we decide to
compare the C value with all the digits of the int captures in a list (compare
143 as if it were ['1','4','3']), and then do the standard list comparison.
For these semantics, we can rewrite __lt__ as 

    def __lt__(self,right):
        if type(right) is C:
            return self.los < right.los
        elif type(right) is int:
            return self.los < [d for d in str(right)]
        else:
            raise TypeError('unorderable types: C() < '+str(type(right))[8:-2]+'()')

Here, if the type of right object is C, we do the standard list comparison we
did before, but if the type is int, we perform the necessary conversion before
doing the list comparison. If neither is the type of right, we raise the
Type exception, meaning the trying to do the comparison is not valid.
The magic having to do with the slice [8:-2] is because str(type(...)) produces
a string of the form "<class '...'>" where the first ... starts at index 8 and
ends 3 before the end of the string.

---
goody.py interlude
I have added the function

    def type_as_str(x):
        return str(type(x))[8:-2]

to the goody.py class. I will write calls to that function in subsequent code
in the lectures
---

Now it is time to explore an interesting asymmetry when Python evaluate
relational operators, and how to avoid any possible problems.

If we extend __lt__ to cover a right argument that is an int (as we did above)
and do not define an explicit __gt__ method similarly, then Python will try, but
fail to compute print(x > 15) correctly: remember that Python would first
translate this expression into type(x).__gt__(x,15)  which is equivalent to
C.__gt__(x,15); if __gt__ is not defined, Python tries to compute x > 15
equivalently by computing 15 < x. But this expression won't work correctly,
because Python will translate 15 < x into type(15).__lt__(15,x) which is
equivalent to int.__lt__(15,x); but the int  class does not (and cannot -see the
next paragraph) know how to compare an int object to a C object. Pyhton would
raise the exception: TypeError: unorderable types: int() > C()

The class int was written before we wrote the class C, so it know nothing about
comparing ints to objects constructed from class C. And, we cannot change the
int class to compare ints against objects constructed from class C. So, it is
class C that must know how to compare ints against objects constructed from
class C. Thus, if it makes sense to compare objects of class C against ints
(and objects of any other defined classes) we must define all 6 relational
operators in class C, each one explicitly performing its comparison.

As the last loose end, notice that if C defines all 6 relational operators to
work with an int right argument, then writing print(15 < x) works as follows.
It first translates 15 < x into type(15).__lt__(15,x) which is equivalent to
int.__lt__(15,x); but the __lt__ method defined in int raises an exception when
it tries to process the second argument: an object constructed from class C.
But in this case, Python tries to evaluate 15 < x by evaluating x > 15, which
translates into type(x).__gt__(x,15) which is equivalent to C.__gt__(x,15),
which computes the correct answer (assuming we have defined __gt__ properly in
class C).

Recall that chained relational operators are translated into pairwise
comparisons joined by and: e.g., a < b < c == d: a < b and b < c and c == d.

Finally note that we can make a < b do whatever we want. We could make it print
values, change the state of a or b, do whatever we can do with Python code.
Here is where beginners might go wild by adding all sorts of strange meanings
to using the < operator; but more experience programmers will ensure that all
relational operators are pure accessors and just return a bool value (not even
one that can be interpreted as a bool value using the __bool__ method) without
making any state changes in the arguments.

We can summarize the rule Python uses to determine how to compute x < y:

  (1) Try to call type(x).__lt__(x,y)
  (2) If this produces a result, that is the result of the expression
  (3) If there is no such __lt__ method, or calling it raises an exception,
        (which is handled by Python), then call type(y).__gt__(y,x); if there is
        no such __gt__ method, or calling it raises an exception propagate the
        exception (Python doesn't handle it)

------------------------------------------------------------------------------

__repr__ and __str__ (and other conversion functions)

Python can call two methods that should return string representations of an
object. The __str__ method is called when the conversion function str is called:
so again, this is like len: Python translates str(x) into type(x).__str__(x).
For example, the print function calls str on all the arguments it is printing.
In fact, if there is no __str__ method in this class, or it raises the
NotImplementedError exception, Python tries calling the __repr__ method next
(if we call repr(x) Python returns x.__repr__() for this method, similarly to
what it does for len(x)): if that too fails, Python reverts to its standard
method for computing a string value objects: a bracket string with the name of
the object's class and the location of this object in memory (as a hexidecimal
number).

So in the class C as it was defined above, if we write

x = C(['ab','cd'])
print(x)

Python prints something like

  <__main__.C object at 0x0289B8D0>

The requirement for __repr__ is that it returns a string, which if passed
as the argument to the eval function, would produce an object with the same
state. So for C, we define __repr__ as follows

    def __repr__(self):
        return 'C(' + str(self.los) + ')'

Now, if we executed the code above, Python prints the following (there is still
no definition of __str__, so __repr__ is called).

  C(['ab', 'cd'])

And sure enough, calling eval(str(x)) would produce an object whose state was
the same as x's object state.

The advice for __str__ is that it return a string that nicely formats 
interesting aspects (maybe all instance variables, maybe not) of the object.
Some objects have more instance variables than those needed to construct the
object. The __str__ below just returns the list of string

    def __str__(self):
        return str(self.los)
    
Now, if we executed the code above, Python prints the following

  ['ab', 'cd']

If we decided we wanted to return a string that contained one concatenation
of all the strings in the list of strings, we could instead define __str__ as

    def __str__(self):
        return ''.join(self.los)

Now, if we executed the code above, Python prints the following

  abcd

Unlike for __repr__, Python places no requirements for resul that __str__ 
returns, we we can use our judgement as to how best to show the string
representation of objects. We will go back to the original definition of
__str__ for the rest of this lecture.
    
Finally the other type coversion functions: int float complex oct hex index
trunc call the Python methods __int__  __float__  __complex__  __oct__  __hex__
__index__  __trunc__  __coerce__.

So, we could define

    def __int__(self):
        return len(self.lof))

If we did, and assumed x = C(['ab','cd']), then int(x) would return 2; if we
did not define any __int_ function, calling int(x) would raise the following
exception: TypeError: int() argument must be a string or a number, not 'C'

------------------------------------------------------------------------------

Unary arithmetic operators: + - ~ (and functions: abs round floor ceil trunc)

Continuing with overloading operators, when Python recognizes a unary
arithmetic operator (or a binary arithmetic operator, see the next section)
it translates it into the appropriate method call for the class/type of its
argument: for example, it translates -x into type(x).__neg__(x). Suppose that
we wanted the __neg__ operator for C to return an object of class C whose list
of string contents is reversed. Generally, as described above, __neg__ should
not mutate its operand but should leave it operand unchanged and return a new
object of the type C, whose state is initialized to the appropriate one. Here
is a __neg__ method with these semantics. Note it returns a newly constructed
object (of class C) with the appropriate contents,

    def __neg__(self):
        return C([i for i in reversed(self.los)])

Here is an example of it code running

x = C(['ab','cd'])
print(x)
print(-x)

which produces the following results; note x's state before and after printing
-x is the same: there is no mutation. Of course we could write x = -x which
also has no mutation, but the name x would be rebound to the object produced by
calling __neg__, so if we printed x again we would see a different result. 

  ['ab', 'cd']
  ['cd', 'ab']
  ['ab', 'cd']

There are two other unary arithmetic operators that we can overload: + and ~
whose methods go by the names __pos_ and __invert__.

In addition, while discussing arithmetic here, the following unary functions 
(all defined in the math module) abs, round, floor, ceil, trunc work by calling
one of these special methods on its argument (much like len, described above):
so abs(x) returns as its result x.__abs__(). Therefore, if we defined the
following __abs__ method in class C (it returns an object constructed from
class C storing a list of non-empty strings)

    def __abs__(self):
        return C([a for a in self.los if a != ''])

then running the script

x = C(['a','','b'])
print(abs(x))
print(x)

would print

['a', 'b']    eliding '' from the list stored in the new C object
['a','','b']  note that the object x refers to was not mutated

------------------------------------------------------------------------------

Binary Arithmetic Operators: + - * / // % divmod ** << >> & | ^

Now lets move from unary to binary operators, where there are more operators
and they are it bit harder to write correctly. We will start by discussing one
method in particular __plus__ and also discuss the need for another related
method __rplus__. What we learn about these methods applies identically to all
the arithmetic operators.

Binary arithmetic operators, like relational operators, are written in between
their two operands. Python translates the call x + y into type(x).__add__(y).
As with the unary arithmetic operators, neither operand should be mutated, and
the method should return a new object initialized with the correct state. Here
is an example of the + operator overloaded for C: the resulting object has its
list of string the catenated list of strings of its operands: recall catenation
for lists also uses the + operator.

    def __add__(self,right):
        return C(self.los+right.los)

and an example of it running

x = C(['ab','cd'])
print(x + C(['12','34']))

which produces the result

['ab', 'cd', '12', '34']

Notice the + operator in __add__ is not recursive! Python calls the __add__
method above when adding two C() objects; inside this method the + operator
is called on two lists, so it calls the method list.__add__(self.los,right.los)
(an __add__ method in a different class) to compute the list used to initalize
the newly constructed C object that this function returns.

Now recall that we allowed objects from class C to compare to int using
relational operators: we interpreted the int 132 as ['1','3','2']. Let's use
this same interpretation for allowing objects from class C to be added to ints.
To do so we extend __add__ in a way similar to we extended relational operators.

    def __add__(self,right):
        if type(right) is C:
            return C(self.los + right.los)
        elif type(right) is int:
            return C(self.los + [d for d in str(right)])
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')

and an example of it running

x = C(['ab','cd'])
print(x + 132)

which produces the result

['ab', 'cd', '1', '3', '2']

What if we also wanted to allow the expression 132 + x? If we try to execute
this code, unsurprisingly Python responds by raising an exception:  TypeError:
unsupported operand type(s) for +: 'int' and 'C' because Python calls 
int.__add__(132,x) and the int class has no clue about objects of type C (and
we cannot change this class to process C's correctly).

Recall that we covered this problem when discussing __lt__: because the class
of the left operand is used to call the method (sometimes called "left-operand
dispatch", we would have to change the definition of __lt__ in the int class
to know about class C, which we cannot do. This problem was solved with
relational operators by Python reversing the operands and calling the __gt__
method: 12 < x always has the same values as x > 12, where the __gt__ method
for x (constructed from class C) can include code that checks whether its right
operand it an int.

For binary arithmetic operators, Python cannot find an equivalent operator to
transpose the operands, so it uses a different mechanism to solve this problem.

For every binary arithmetic operator, Python also allows us to define a "right"
version of it: where the method name is prefixed by an r: so __add__ has an
equivilant __radd__ method ("right add"). Here is how we could define __radd__
in class C to successfully compute expressions of the form int() + C(). When
Python evaluates 123 + x, it first tries int.__add(123,x); it doing so raises
an exception, Python translates the + into type(x).__radd__(x,123) using "right-
operand dispatch". This methods determines what to do if the left operand is an
int. In the method below, relating to the + operator, the self parameter is the
right operand and the left parameter is the left operand.

    def __radd__(self,left):
        if type(left) is int:
            return C([d for d in str(left)] + self.los)
        else:
            raise TypeError('unaddable types: '+type_as_str(left)+'() + C()')

and an example of it running

x = C(['ab','cd'])
print(132 + x)

which produces the result

['1', '3', '2', 'ab', 'cd']

For arithmetic types/operators that are commutative (e.g., a+b == b+a) we can
write __radd__ by simply calling __add__ with the arguments reversed: e.g., 

    def __radd__(self,left):
        self + left  # or self.__add__(left)

Note this the + operator for class C is not communtative: x + 132 != 132 + x.
There are many mathematical structures where + and * are commutative, although
 operators like - and / are typically not commutative. In fact, some
interpretations of + and/or * are not commmutative (e.g., class C and
multiplyingm matrices). So, we must be careful to write the normal and right
versions of all binary arithmetic operarators correctly.

We now get a point where we can really test our understanding. Here is the rule
Python uses to determine how to compute x + y:

  (1) Try to call type(x).__add__(x,y)
  (2) If this produces a result, that is the result of the expression
  (3) If there is no such __add__ method, or calling it raises an exception,
        (which is handled by Python), then call type(y).__radd__(y,x); if there
        is no such __radd__ method, or calling it raises an exception propagate
        the exception (Python doesn't handle it)

So, an interesting question is, why doesn't the __radd__ method need to also
specify the following, as the __add__ method does, which has code that specifies
what to do for objects of type C in both its left and right operands?

        if type(left) is C:
            return C(left.los + self.los)

The answer is, by the rules listed above, the test type(left) is C would always
evaluate to True. This is because if Python calls C.__radd__, calling C.__add__
failed, but since it called C.__add__ the first operand must be constructed
from class C; so when calling C.__radd__ the parameter left must be constructed
from class C.

For a similar reason, we don't need to check whether the self parameter in
C.__add__ is constructed from class C: it must be because Python called the
__add__ method in C, so the type of the first operand must be C.

We have now explored (in about 150 lines of text and code) the relationship
between the + operator and __add__ and __radd__ methods. Here is the complete
list of  operators and their related methods: + - * / // % divmod ** << >> & | ^
translate to __add__  __sub__  __mul__  __truediv__  __floordiv__  __mod__
 __divmod__ __pow__ __lshift__  __rshift__  __and__  __or__  __xor__; also
there is a right form for each of these method: __radd__, __rsub__, __rmul__, 
etc.

One final comment, for arithmetic - operator, if one had defined -/__neg__ one
can often implement the __sub__ method as self + -right, which uses the __neg__
and __add__ methods to compute subtraction: again, this can be a bit
inefficient, but it is easy to code.

------------------------------------------------------------------------------

Incrementing Arithmetic Delimiters: += -= *= /= //= %= **= <<= >>= &= |= ^=

Again in this section we will look at one incrementing arithmetic delimiter,
+=. Technically this is not an operator, because we cannot compose bigger
expressions with it: += is more like = than +. This same discussion applies
similarly to all the other delimiters. For every arithmetic operator method,
there is another method prefaced by i that we can write and Python will try
to call (e.g. __add__ and __iadd__).

Recall that the meaning of x += y is similar to x = x + (y). We parenthesize y
in case it contains any operators whose precedence is lower than +. When Python
executes x += y, it tries to call the type(x).__iadd__(x,y): if that method is
available and doesn't raise an exception, that is the result; if it cannot find
that method or it raises an exception, Python executes the code x = x + (y),
which can fail if __add__ is not defined for the types of x and y.

Note that unlike arithmetic operators, __iadd__ should mutate (after examining)
the object that x refers to, and should return the value self (the object the
method is called on). I'm not sure why this is: technically, it should make no
difference what value we return, because we can do nothing with the returned
value: it is illegal syntax to write, for example, print(x += 1). But it seems
as if I return, say None, then x += 1 makes x refer to None (I'm still thinking
about this).

Here is an example of the __iadd__ method for the C class, which works for
incrementing by objects of type/class C and int.

    def __iadd__(self,right):
        if type(right) is C:
            for v in right.los:
                self.los.append(v)
        elif type(right) is int:
            for d in str(right)
                self.los.append(d)
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')

        return self

So, what is the difference between executing this method instead of using the
= delimiter and __add__ method. Both will update the variable x to exactly the
same value, but this one more efficiently.

Notice that the __iadd__ method uses for loops to append all the needed values.
The __add__ method uses catenation (and a comprehension for an int), both of
which create new objects (whereas __iadd__ mutates an existing object). 

Sometimes object creation is wasteful in time and space, and if it wastes a lot
of time or space, we should write an __iadd__ method to avoid such a waste.
There are times times where the waste is not much, so it is not worth our time
as programmers to define the __iadd__ method, and instead we should let Python
automatically translate such statements into a combination of using = and
__add__.

Here is the complete list of arithmetic incrementing delimiters and their
related methods: += -= *= /= //= %= **= <<= >>= &= |= ^= translate to __iadd__
 __isub__  __imul__  __itruediv__  __ifloordiv__  __imod__  __idivmod__
__ipow__  __lishift__  __irshift__  __iand__  __ior__  __ixor__.

------------------------------------------------------------------------------

Other overloaded operators (coming up)

In the next lecture we will discuss container operators (including [index]),
the call operator (using ()), the context manager protocol, and managing simple
attributes. Next week we will have a lengthy discussion about the intricacies of
implementing the iterator protocol (and the __iter__ and __next__ methods)

------------------------------------------------------------------------------

FYI, here is the entire C class with all the methods described above. We can
put this class in a script and experiment calling its methods.

class C:
    def __init__(self,los):
        self.los = los
        
    def __len__(self):
        return sum((len(i) for i in self.los))
    
    def __bool__(self):
        return ''.join(self.los) != 'False'
    
    def __lt__(self,right):
        if type(right) is C:
            return self.los < right.los
        elif type(right) is int:
            return self.los < [d for d in str(right)]
        else:
            raise TypeError('unorderable types: C() < '+type_as_str(right)+'()')
        
    def __gt__(self,right):
        if type(right) is C:
            return self.los > right.los
        elif type(right) is int:
            return self.los > [d for d in str(right)]
        else:
            raise TypeError('unorderable types: C() > '+type_as_str(right)+'()')

    def __le__(self,right):
        return (self < right) or self == right
    
    def __ge__(self,right):
        return (self > right) or self == right
    
    def __eq__(self,right):
        return self.los  == right.los
    
    def __ne__(self,right):
        return not (self == right) 
    
    def __repr__(self):
        return 'C(' + str(self.los) +')'

    def __str__(self):
        return str(self.los)

    def __neg__(self):
        return C([i for i in reversed(self.los)])

    def __abs__(self):
        return C([a for a in self.los if a != ''])

    def __add__(self,right):
        if type(right) is C:
            return C(self.los + right.los)
        elif type(right) is int:
            return C(self.los + [d for d in str(right)])
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')
    
    def __radd__(self,left):
        if type(left) is int:
            return C([d for d in str(left)] + self.los)
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')
    
    def __iadd__(self,right):
        if type(right) is C:
            for v in right.los:
                self.los.append(v)
        elif type(right) is int:
            for d in str(right)
                self.los.append(d)
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')

        return self


------------------------------------------------------------------------------

Problems:

1) Using your knowledge of the or operator, and the boolean interpretation of
string values, explain what the following statement

   x = string1 or string2

assigns to x in each of the following cases (of empty and non-empty strings)

  string1  |  string2
  ---------+----------
    ''     |     'a'
    ''     |     ''
    'a'    |     ''
    'a'    |     'b'

Rewrite this statement as an equivalent (a) conditional statement and
(b) conditional expression.


2) Assume that we define x = C(['0']) where the class C is defined by

class C:
    def __init__(self,los):
        self.los = los

    def __lt__(self,right):
        if type(right) is C:
            return self.los < right.los
        elif type(right) is int:
            return self.los < [d for d in str(right)]
        else:
            raise TypeError('unorderable types: C() < '+type_as_str(right)+'()')

    def __gt__(self,right):
        return right < self

Explain in detail (as I did in this lecture) how Python attempts to evaluate
12 < x and whether it succeeds or fails, and if it fails -hint: it fails- how
and why it fails.

Answer the same question, if we replaced the defintion of __gt__ above by

    def __gt__(self,right):
        return C.__lt__(right,self)

3) Assume that we define the class C below

class C:
    def __init__(self,los):
        self.los = los

    def __add__(self,right):
        if type(right) is C:
            return C(self.los + right.los)
        elif type(right) is int:
            return C(self.los + [d for d in str(right)])
        else:
            raise TypeError('unaddable types: C() + '+type_as_str(right)+'()')

In what cases can we guarantee that when __add__ is called, self is guaranteed
to be an object constructed from class C? Explain how we can call this method
with a self object that is not constructed from class C.
